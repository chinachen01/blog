<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Glide 源码分析(1):图片压缩]]></title>
    <url>%2Fblog%2F2019%2F01%2F04%2FGlide-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[关于图片的那点事儿Q: 一张大小为 55KB, 分辨率为 1080 * 480 的 PNG 图片，它加载近内存时所占的大小是多少呢？ 图片内存大小图片占用内存大小 = 分辨率 * 像素点大小 其中数据格式不同像素点大小也不同： ALPHA_8: 1B RGB_565: 2B ARGB_4444: 2B ARGB_8888: 4B RGBA_F16: 8B 现在回过头来看上面的问题，在电脑上显示 55KB 的图片，png 只是这张图片的容器，他们是经过相对应的压缩算法将原图的每个像素点信息转换为另一种数据格式。 在一般情况下，这张图片占用的内容应该是：1080 480 4B = 1.98 M。 每种设备都会有所差异，以 android 为例，我们将同一张图片放在不同 dpi 的 res/drawable 目录下，占用的内存也不一样。 这是因为在 android 中 Bitmap.decodeResource()会根据图片存放的目录做一次宽高的转换，具体公式如下： 转换后高度 = 原图高度 * （设备的 dpi /目录对应的 dpi ） 转换后宽度 = 原图宽度 * （设备的 dip / 目录对应的 dpi） 假设你的手机 dpi 是 320（对应 xhdpi），你将上述的图片放在 xhdpi 目录下： 图片占用内存 = 1080 (320 / 320) 480 (320 / 320) 4B = 1.98 M 同样的手机，将上述图片放到 hdpi (240 dpi) 目录下： 图片占用内存 = 1080 (320 / 240) 480 (320 / 240) 4B = 3.52 M 如果需要查看手机 density 相关配置，可以使用如下命令： adb shell cat system/build.prop|grep density 该命令可得到手机的 dpi，平常我们在布局中的单位都是 dp，那 1 dp 等于多少 px 呢。 根据官方转换公式在 160 dpi 手机下 1 dp 等于 1 px，如果手机 dpi 为 440 dpi，则 1 dp = 2.75 px 如何降低一张图片占用的内存Bitmap 相关属性说明简单了解下BitmapOption的几个相关属性: inBitmap——在解析Bitmap时重用该Bitmap，不过必须等大的Bitmap而且inMutable须为true inMutable——配置Bitmap是否可以更改，比如：在Bitmap上隔几个像素加一条线段 inJustDecodeBounds——为true仅返回Bitmap的宽高等属性 inSampleSize——须&gt;=1,表示Bitmap的压缩比例，如：inSampleSize=4，将返回一个是原始图的1/16大小的 Bitmap inPreferredConfig——Bitmap.Config.ARGB_8888等 inDither——是否抖动，默认为false inPremultiplied——默认为true，一般不改变它的值 inDensity——Bitmap的像素密度 inTargetDensity——Bitmap最终的像素密度 inScreenDensity——当前屏幕的像素密度 inScaled——是否支持缩放，默认为true，当设置了这个，Bitmap将会以inTargetDensity的值进行缩放 inPurgeable——当存储Pixel的内存空间在系统内存不足时是否可以被回收 inInputShareable——inPurgeable为true情况下才生效，是否可以共享一个InputStream inPreferQualityOverSpeed——为true则优先保证Bitmap质量其次是解码速度 outWidth——返回的Bitmap的宽 outHeight——返回的Bitmap的高 inTempStorage——解码时的临时空间，建议16*1024 降低分辨率android 系统提供了相应的 api 可以按比例压缩图片 BitmapFactory.Options.inSampleSize inSampleSzie 值越大，压缩比例越高 改变数据格式 android 系统默认以 ARGB_8888 格式处理图片，那么每个像素点就需要占用 4B 大小，可以将格式改为 RGB_565 Glide 中的图片压缩图片加载的简单过程我们使用 Glide 加载图片的最后一步是 #into(ImageView) 我们直接定位到 RequestBuilder#into(ImageView) 方法： 1234BaseRequestOptions&lt;?&gt; requestOptions = this;... // 根据 ImageView 原生的 scale type 构建 Glide 的 scale typeRequest = buildRequest(target, targetListener, options) // 这里最终调用的是 SingleRequest.obtain() 来创建 requestrequestManager.track(target, request); //从这里开始请求 URL 加载图片 在 tarck() 方法中执行了 targetTracker.track(target)，而这行代码就是用来跟踪生命周期的 如果我们是从网络加载图片，当图片下载成功后会回调 SingleRequest#onResourceReady(Resource&lt;?&gt; resource, DataSource dataSource)方法。 而图片的下载及解码起始于 SingleRequest#onSizeReady,然后调用 Engine#load() 开始下载及解码： 123456... //省略分别从内存，disk 读取图片代码EnginJob&lt;R&gt; engineJob = engineJobFactory.build();DecodeJob&lt;R&gt; decodeJob = decodeJobFacotry.build();josbs.put(key, enginJob);engineJob.addCallback(cb);engineJob.start(decodeJob); //开始解码工作 最后调用 DecodePath#decodeResourceWithList()，关键代码： 123456Resource&lt;ResourceType&gt; result = null;for (int i = 0, size = decoders.size(); i &lt; size; i++) &#123; ResourceDecoder&lt;DataType, ResourceType&gt; decoder = decoders.get(i); result = decoder.decode(data, width, height, options);&#125;return result; 图片解码接下来分析图片的解码过程。 首先我们需要搞清楚 decoders 是怎么来的，原来在初始化 Glide 时会将 Glide 支持的所有 Decoder 注册到 decoderRegistry 中，最终调用 ResourceDecoderRegistry#getDecoders()方法来获取所需要的 decoders: 123456789101112131415161718public synchronized &lt;T, R&gt; List&lt;ResourceDecoder&lt;T, R&gt;&gt; getDecoders(@NonNull Class&lt;T&gt; dataClass, @NonNull Class&lt;R&gt; resourceClass) &#123; List&lt;ResourceDecoder&lt;T, R&gt;&gt; result = new ArrayList&lt;&gt;(); for (String bucket : bucketPriorityList) &#123; List&lt;Entry&lt;?, ?&gt;&gt; entries = decoders.get(bucket); if (entries == null) &#123; continue; &#125; for (Entry&lt;?, ?&gt; entry : entries) &#123; if (entry.handles(dataClass, resourceClass)) &#123; result.add((ResourceDecoder&lt;T, R&gt;) entry.decoder); &#125; &#125; &#125; // TODO: cache result list. return result; &#125; 在Glide中 ResourceDecoder 的实现类有很多，如下图所示 Glide 根据图片的资源类型会调用不同的 Decoder 进行解码，现在我们以最常见的场景，加载网络图片来说明。加载网络图片（PNG格式）调用的是 ByteBufferBitmapDecoder。 不管是加载网络图片还是加载本地资源，都是通过 ByteBufferBitmapDecoder 类进行解码 1234567891011121314151617181920public class ByteBufferBitmapDecoder implements ResourceDecoder&lt;ByteBuffer, Bitmap&gt; &#123; private final Downsampler downsampler; public ByteBufferBitmapDecoder(Downsampler downsampler) &#123; this.downsampler = downsampler; &#125; @Override public boolean handles(@NonNull ByteBuffer source, @NonNull Options options) &#123; return downsampler.handles(source); &#125; @Override public Resource&lt;Bitmap&gt; decode(@NonNull ByteBuffer source, int width, int height, @NonNull Options options) throws IOException &#123; InputStream is = ByteBufferUtil.toStream(source); return downsampler.decode(is, width, height, options); &#125;&#125; 该类很简单，最主要的是调用Downsampler#decode方法，Downsampler 直译向下采样器，接下来就重点看下该类。 Downsampler首先来看 Downsampler对外提供的方法 decode方法 12345678910111213141516171819202122232425 public Resource&lt;Bitmap&gt; decode(InputStream is, int requestedWidth, int requestedHeight, Options options, DecodeCallbacks callbacks) throws IOException &#123; Preconditions.checkArgument(is.markSupported(), "You must provide an InputStream that supports" + " mark()");/* 开始构建 BitmpFactory.Options */ byte[] bytesForOptions = byteArrayPool.get(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, byte[].class); BitmapFactory.Options bitmapFactoryOptions = getDefaultOptions(); bitmapFactoryOptions.inTempStorage = bytesForOptions; DecodeFormat decodeFormat = options.get(DECODE_FORMAT); DownsampleStrategy downsampleStrategy = options.get(DownsampleStrategy.OPTION); boolean fixBitmapToRequestedDimensions = options.get(FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS); boolean isHardwareConfigAllowed = options.get(ALLOW_HARDWARE_CONFIG) != null &amp;&amp; options.get(ALLOW_HARDWARE_CONFIG); try &#123; Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions, downsampleStrategy, decodeFormat, isHardwareConfigAllowed, requestedWidth, requestedHeight, fixBitmapToRequestedDimensions, callbacks); return BitmapResource.obtain(result, bitmapPool); &#125; finally &#123; releaseOptions(bitmapFactoryOptions); byteArrayPool.put(bytesForOptions); &#125; &#125; 该方法首先为 BitmapFactory.Options 设置所需要的参数 inTempStorage Temp storage to use for decoding. Suggest 16K or so. Glide 在这里用的是 64k decodeFormat 解码格式, glide 中的图片主要为两种模式 ARGB_8888, RGB_565 fixBitmapToRequestedDimensions 默认为 false（暂时不太理解这个属性的含义，也无法设置成 true） isHardwareConfigAllowed 硬件位图 默认禁用 123boolean isHardwareConfigSafe = dataSource == DataSource.RESOURCE_DISK_CACHE || decodeHelper.isScaleOnlyOrNoTransform();Boolean isHardwareConfigAllowed = options.get(Downsampler.ALLOW_HARDWARE_CONFIG); 接下来通过 decodeFromWrappedStream 获取 bitmap，该方法主要逻辑如下： 1234567int[] sourceDimensions = getDimensions(is, options, callbacks, bitmapPool); //获取原始图片的宽高 int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth; int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;calculateScaling(); //设置 inSampleSize 缩放(采样)比例calculateConfig();Bitmap downsampled = decodeStream(is, options, callbacks, bitmapPool);callbacks.onDecodeComplete(bitmapPool, downsampled); 我们先来理清这几个size,以 width 为例 sourceWidth: 即你从网络下载的原始图片的宽 requestedWidth: 默认为 ImageView 的宽 targeWidth: 最终生成的 bitmap 的宽 接下来分析 calculateScaling 方法 由于都是计算相关，所以举个栗子，假设图片的sourceWidth 为 1000， targetWidth为 200， sourceHeight为 1200， targetWidth 为 300 123456789101112131415161718192021222324252627final float exactScaleFactor = downsampleStrategy.getScaleFactor(sourceWidth, sourceHeight, targetWidth, targetHeight); //假设向下采样策略为 CenterOutside 实现，则exactScaleFactor 等于 0.25SampleSizeRounding rounding = downsampleStrategy.getSampleSizeRounding(sourceWidth, sourceHeight, targetWidth, targetHeight); //rouding 为 QUALITYint outWidth = round(exactScaleFactor * sourceWidth); //outWidth = 0.25*1000 + 0.5 = 250int outHeight = round(exactScaleFactor * sourceHeight); // outHeight = 0.25*1200 + 0.5 = 300 int widthScaleFactor = sourceWidth / outWidth; //widthScaleFactor = 1000/250 = 4int heightScaleFactor = sourceHeight / outHeight; //heightScalFactor = 1200/300 = 4int scaleFactor = rounding == SampleSizeRounding.MEMORY //scaleFactor = 4 ? Math.max(widthScaleFactor, heightScaleFactor) : Math.min(widthScaleFactor, heightScaleFactor);int powerOfTwoSampleSize = Math.max(1, Integer.highestOneBit(scaleFactor)); //powerOfTowSampleSize = 4，且只可能是 1，2，4，8，16 ...if (rounding == SampleSizeRounding.MEMORY &amp;&amp; powerOfTwoSampleSize &lt; (1.f / exactScaleFactor)) &#123; powerOfTwoSampleSize = powerOfTwoSampleSize &lt;&lt; 1; &#125;&#125;options.inSampleSize = powerOfTwoSampleSize;// 这里暂时还不太理解，看算法这里的 inTragetDesity 和 inDensity 的比值永远为 1if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; options.inTargetDensity = adjustTargetDensityForError(adjustedScaleFactor); options.inDensity = getDensityMultiplier(adjustedScaleFactor);&#125;if (isScaling(options)) &#123; options.inScaled = true;&#125; else &#123; options.inDensity = options.inTargetDensity = 0;&#125; 我们简单看下 CenterOutside类，代码很简单： 12345678910111213 public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) &#123; float widthPercentage = requestedWidth / (float) sourceWidth; float heightPercentage = requestedHeight / (float) sourceHeight; return Math.max(widthPercentage, heightPercentage); &#125; @Override public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) &#123; return SampleSizeRounding.QUALITY; // 返回值有 QUALITY 和 MEMORY,其中 MEMORY 相比较 QUALITY 会占用更少内存 &#125;&#125; 接下来通过调用calculateConfig为 options 设置其他属性 1234567891011121314151617181920212223242526272829303132if (hardwareConfigState.setHardwareConfigIfAllowed( targetWidth, targetHeight, optionsWithScaling, format, isHardwareConfigAllowed, isExifOrientationRequired)) &#123; return;&#125;// Changing configs can cause skewing on 4.1, see issue #128.if (format == DecodeFormat.PREFER_ARGB_8888 || Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN) &#123; optionsWithScaling.inPreferredConfig = Bitmap.Config.ARGB_8888; return;&#125;boolean hasAlpha = false;try &#123; hasAlpha = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool).hasAlpha();&#125; catch (IOException e) &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, "Cannot determine whether the image has alpha or not from header" + ", format " + format, e); &#125;&#125;optionsWithScaling.inPreferredConfig = hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;if (optionsWithScaling.inPreferredConfig == Config.RGB_565) &#123; optionsWithScaling.inDither = true;&#125; 最终调用 ecodeStream 方法，该方法通过对 android api BitmapFactory#decodeStream对图片进行压缩获得了 bitmap 对象 特别注意的是我们在使用 Glide 时加载的网络图片时，默认都是根据 ImageView 的尺寸大小进行了一定比例的，详细的计算过程在上文中也已经提到。但在实际应用中会有希望让用户看到原图场景，这个时候我们可以这样操作 12345ImgurGlide.with(vh.imageView) .load(image.link) .diskCacheStrategy(DiskCacheStrategy.RESOURCE) // 硬盘缓存保存原图 .override(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL) // 重载 requestSize，避免 bitmap 被压缩 .into(vh.imageView); Skia 库在 android 中， BitmapFactory.decodeStream 调用的是 natvie 方法，该函数最终调用的是 skia 库中的encodeStream函数来对图片进行压缩编码。接下来大致介绍一下skia库。 Skia 是一个 c++实现的代码库，在android 中以扩展库的形式存在，目录为external/skia/。总体来说skia是个相对简单的库，在android中提供了基本的画图和简单的编解码功能。另外，skia 同样可以挂接其他第3方编码解码库或者硬件编解码库，例如libpng和libjpeg。在Android中skia就是这么做的，\external\skia\src\images文件夹下面，有几个SkImageDecoder_xxx.cpp文件，他们都是继承自SkImageDecoder.cpp类，并利用第三方库对相应类型文件解码，最后再通过SkTRegistry注册，代码如下所示123static SkTRegistry&lt;SkImageDecoder*, SkStream*&gt; gDReg(sk_libjpeg_dfactory);static SkTRegistry&lt;SkImageDecoder::Format, SkStream*&gt; gFormatReg(get_format_jpeg);static SkTRegistry&lt;SkImageEncoder*, SkImageEncoder::Type&gt; gEReg(sk_libjpeg_efactory); Android编码保存图片就是通过Java层函数——Native层函数——Skia库函数——对应第三方库函数（例如libjpeg），这一层层调用做到的。 最后推荐一个第三方库glide-transformations，可以实现很多图片效果，比如圆角，高斯模糊，黑白。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Glide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴开源路由框架 - ARouter 分析]]></title>
    <url>%2Fblog%2F2019%2F01%2F04%2F%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E8%B7%AF%E7%94%B1%E6%A1%86%E6%9E%B6-ARouter-%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Arouter 一个用于帮助 Android App 进行组件化改造的框架 —— 支持模块间的路由、通信、解耦 技术准备 SPI APT 源码分析我们直接看官方 demo，核心模块包括api,compiler,annotation, 首先先简单讲一下各模块的作用： Annoation: 定义注解和 Route 相关的基本信息 Compiler: 主要是用来在编译期间处理注解Router/Interceptor/Autowire三个注解，在编译期间自动注册注解标注的类，成员变量等。 Api: 用户调用的核心 api annoationAutowired 用于注解 field, 可实现路由件传递参数的自动注入，无需使用者在代码中去获取传递的参数，注意，注解对象的修饰符不能是 private。 Interceptor 用于注解拦截器，拦截器的概念请参考官方文档 Route 路由注解，可以是 Activity，也可以是 Service RouteMeta 路由相关的数据，包括路由类型，路径，组，权重，参数等信息 compilerRouteProcessor路由注解器 关键方法 #parseRoutes#,我们先看这个方法最后生成的文件到底是啥，弄清楚了才能更容易的理清代码。 123456789public class ARouter$$Root$$app implements IRouteRoot &#123; public ARouter$$Root$$app() &#123; &#125; public void loadInto(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes) &#123; routes.put("service", service.class); routes.put("test", test.class); &#125;&#125; 注意map 存入的key 分别是 service 和 test，valude 则对应为 ARouter$$Group$$service.class 和 ARouter$$Group$$test.class。一个组件有且只有一个 Root 类，不同的组件以后缀作为区分。 12345678public class ARouter$$Group$$test implements IRouteGroup &#123; public ARouter$$Group$$test() &#123; &#125; public void loadInto(Map&lt;String, RouteMeta&gt; atlas) &#123; atlas.put("/test/*", RouteMeta) &#125;&#125; 12345678public class ARouter$$Group$$service implements IRouteGroup &#123; public ARouter$$Group$$service() &#123; &#125; public void loadInto(Map&lt;String, RouteMeta&gt; atlas) &#123; atlas.put("/service/*", RouteMeta) &#125;&#125; 注意 Arouter$$Group$$test 中 map 的 key 必然是以 “/test” 为前缀，刚好与其后缀相同 12345678public class ARouter$$Providers$$app implements IProviderGroup &#123; public ARouter$$Providers$$app() &#123; &#125; public void loadInto(Map&lt;String, RouteMeta&gt; providers) &#123; providers.put(className, RouteMeta) &#125;&#125; 12345678public class ARouter$$Interceptors$$app implements IInterceptorGroup &#123; public ARouter$$Interceptors$$app() &#123; &#125; public void loadInto(Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptors) &#123; interceptors.put(privority, Class); &#125;&#125; 小结一下： 在一个module中，自动生成的 IRouteRoot 类有且只有一个，后缀为 module 名 在一个module中，自动生成的 IRouteGroup 类可以有多个，且都会在 IRouteRoot 类中注册 IProviderGroup 只有一个，后缀为 module 名 准确来说后缀并不是 module 名，实际上你可以在 gradle 中指定，后续在讲解 parseRoutes 方法时会讲到具体原因 接下来将讲解 RouteProcessor#parseRoutes 方法: 拿到 Route，根据 RouteType 构建 RouteMeta，并通过 #categoryies 方法构建映射关系存储到 groupMap(groupMap 的 key 为 routeName ，value 则是 RouteMeta 集合) 遍历 groupMap 创建 ARouter\$\$Group\$\$groupName 类, 同时将 groupName 与生成的 File 的全类名的映射关系存储到 rootName 创建 ARouter\$\$Providers\$\$moduleName 类 创建 ARouter\$\$Rout\$\$moudleName 其中 groupName 就是你在注解中设置的 group，但我们平时在使用 ARouter 的时候很少回去设置 group, 如果你没有指定 group，Arouter 会默认使用 path 的主路径，比如你指定了 path = “/test/main”, 那 groupName 就是 test; moudleName 则由你在 gradle 中指定。 AutoWiredProccesor首先看一下生成的文件：1234567891011121314public class Test1Activity$$ARouter$$Autowired implements ISyringe &#123; private SerializationService serializationService; public Test1Activity$$ARouter$$Autowired() &#123; &#125; public void inject(Object target) &#123; this.serializationService = (SerializationService)ARouter.getInstance().navigation(SerializationService.class); Test1Activity substitute = (Test1Activity)target; substitute.name = substitute.getIntent().getStringExtra("name"); ... substitute.helloService = (HelloService)ARouter.getInstance().navigation(HelloService.class); &#125;&#125; 生成的 class 继承之 ISyring只有一个方法 inject(Object),该方法的实现主要做了两件事： AutoWired 注解的 filed 如果是 service (Arouter 中继承自 IProvider), 则初始化对象： 1substitute.helloService = (HelloService)ARouter.getInstance().navigation(HelloService.class); AutoWried 注解的 filed 非 service,则从 bundle 中获取相应的 value 赋值给该 field: 12substitute.helloService = (HelloService)ARouter.getInstance().navigation(HelloService.class); // activitysubstitute.name = substitute.getArguments().getString("name"); // fragment 最后生成类名\$\$Arouter\$\$AutoWired.class 文件 InterceptorProccessor拦截注解生成器 12345678public class ARouter$$Interceptors$$app implements IInterceptorGroup &#123; public ARouter$$Interceptors$$app() &#123; &#125; public void loadInto(Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptors) &#123; interceptors.put(7, Test1Interceptor.class); &#125;&#125; apiARouter &amp; _ARouterlauncher 下只有两个类 ARouter, _ARouter, ARouter 采用单例模式，对外提供 ARouter 相关 API,我们在调用ARouter.getInstance().build()时 真正调用的是_ARouter的相关方法，这里采用了代理模式，现在我们就开始以 ARouter 向外提供的方法来逐步分析： 首先看init():在 Arouter 库中，有一个 Warehose类，它存储了路由相关的信息，我们在使用 ARouter 之前必须要先调用 init 方法，而 init方法就是需要将信息存储到 Warehose 中以下为时序图： 通过调用#loadInto(Warehose)方法，成功地将信息存储到 Warehose。 现在Warehose 的 groupsIndex, providersIndex, interceptorsIndex 已经被我们存入了路由信息 最后再调用_ARouter#afterInit()实例化 interceptorService 接下来是 navigation()方法: 我们需要先了解Postcard 类,Postcard 继承 RouteMeta，扩展了一些属性，例如：flag(activity 的 flag)，uri，provider，anim(动画)。我们平时在是用 Arouter 时 build 方法返回的就是 Postcasrd, postcard#navigation 方法，最终调用的是就是 _Arouter#navaigation 123456789101112LogisticsCenter.completion(postcard);if(!postcard.isGreenChannel()) &#123; // 拦截器相关，暂时跳过 interceptorSevice.doInterceptions(post, new InterceptorCallback() &#123; @Override public void onContinue(Postcard postcard) &#123; _navigation(context, postcard, requestCode, callback); &#125; &#125;)&#125; else &#123; return _navigation(context, postcard, requestCode, callback);&#125; 首先我们来看LogisticsCenter#completion(Postcard)方法 123456789101112131415161718192021222324252627...RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());if (null == routeMeta) &#123; Class&lt;? extends IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup()); // Load route meta. IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance(); // ARouter$$Group%%test 对象实例化 iGroupInstance.loadInto(Warehouse.routes); Warehouse.groupsIndex.remove(postcard.getGroup()); completion(postcard); // Reload 进入 else 分支&#125; else &#123; ... // postcadrd 设置属性如：destination,type,priority等 switch(routeMeta.getType) &#123; case PROVIDER: Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination(); IProvider instance = Warehouse.providers.get(providerMeta); if(instance == null) &#123; IProvider povider = providerMeta.getConstructor().newInstance(); provider.init(mContext); // init 方法只在创建 provider 对象后调用一次, Warehose.providers.put(providerMeta, provider); // 存入 map，除非调用 ARouter#destory, 该 provider 对象会一直存在 map 中 postcard.setProvider(instance); postcard.greenChannel(); &#125; break; case FRAGMENT: ... break; &#125;&#125; 到这里面 Warehose 中的 routes 和providers也被我们放入了相应信息 _navigation()方法： 123456789101112131415switch(postcard.getType()) &#123; case ACTIVITY: ... // build intent startActivity(requestCode, currentCotext, intent, postcard, callback); break; case POSTCARD: return postcard.getProvider(); case Fragment: Fragment fragment = fragmentMeta.getConstructor().newInstance(); fragment.setArguments(postcard.getExtras()); return fragment; default: return null;&#125;return null; 接下来分析 ARroute#inject(Object)方法： 12AutowiredService autowiredService = ((AutowiredService) ARouter.getInstance().build("/arouter/service/autowired").navigation());autowiredService.autowire(objec); 代码很简单，关键是 AutowiredService 的实现 12345678910111213141516@Overridepublic void autowire(Object instance) &#123; String className = instance.getClass().getName(); try &#123; if (!blackList.contains(className)) &#123; ISyringe autowiredHelper = classCache.get(className); if (null == autowiredHelper) &#123; // No cache. autowiredHelper = (ISyringe) Class.forName(instance.getClass().getName() + SUFFIX_AUTOWIRED).getConstructor().newInstance(); // $$ARouter$$Autowired = $$ARouter$$Autowired &#125; autowiredHelper.inject(instance); // Text1Activity$$ARouter$$Autowired.inject(this) 取出 bundle 中传递的参数 classCache.put(className, autowiredHelper); &#125; &#125; catch (Exception ex) &#123; blackList.add(className); // This instance need not autowired. &#125;&#125; 到这里，所有的注解生成的 class 的作用及其实现方法的调用时机都已经介绍到了，相信读者应该对 ARouter 有了新的了解了吧。接下来讲一下我们平时比较少用到的 interceptor ARouter官方为我们提供了一个拦截器的使用场景: 12&gt; 比较经典的应用就是在跳转过程中处理登陆事件，这样就不需要在目标页重复做登陆检查&gt; 还记得在讲解 ARroute#navigation时我们跳过了拦截器相关的内容吗 123456789if(!postcard.isGreenChannel()) &#123; // 拦截器相关，暂时跳过 interceptorSevice.doInterceptions(post, new InterceptorCallback() &#123; @Override public void onContinue(Postcard postcard) &#123; _navigation(context, postcard, requestCode, callback); &#125; &#125;)&#125; 只要是拦截器，一般都会使用责任链设计模式，在 ARouter中也不例外,我们先看 interceptorService的创建过程，它的 type 是 Provider，在创建后会首先调用 init方法 1234567891011121314@Overridepublic void init(final Context context) &#123; LogisticsCenter.executor.execute(new Runnable() &#123; @Override public void run() &#123; for(entry : Warehose.interceptorsIndex) &#123; Class&lt;? extends IInterceptor&gt; interceptorClass = entry.getValue(); IInterceptor iInterceptor = interceptorClass.getConstructor().newInstance(); iInterceptor.init(context); Warehose.interceptors.add(iInterceptor); &#125; &#125; &#125;&#125; interceptorService#doInterceptions 调用 _excute 方法 12345678910111213141516171819private static void _excute(final int index, final CancelableCountDownLatch counter, final Postcard postcard) &#123; if (index &lt; Warehouse.interceptors.size()) &#123; IInterceptor iInterceptor = Warehouse.interceptors.get(index); iInterceptor.process(postcard, new InterceptorCallback() &#123; @Override public void onContinue(Postcard postcard) &#123; // Last interceptor excute over with no exception. counter.countDown(); _excute(index + 1, counter, postcard); // When counter is down, it will be execute continue ,but index bigger than interceptors size, then U know. &#125; @Override public void onInterrupt(Throwable exception) &#123; // Last interceptor excute over with fatal exception. postcard.setTag(null == exception ? new HandlerException("No message.") : exception.getMessage()); // save the exception message for backup. counter.cancel(); &#125; &#125;); &#125; 常见错误分析 service 内存泄漏, 考虑以下代码： 12345678910111213public class HelloServiceImpl implements HelloService &#123; private Context context; @Override public void init(Context context) &#123; this.context = context &#125; @Override public void say() &#123; Toast.makeText(context, R.string.hello, Toast.LENGTH_LONG).show(); &#125;&#125; 之前我们分析源码的时候就已经讲过了，service 的实现类在初始化后会被放入Warehose.providers，后续通过调用ARouter.inject都是从Warehose.providers中取出。在上面的代码中如果 context 是一个 activity 对象，将该 activity 赋值给了成员变量 context，则该 activity 对象不会被回收，造成了内存泄漏 混淆导致 service 为 null 123456789101112public class HelloHolder &#123; @Autowired(name = "/service/hello") HelloService helloService; public HelloHolder() &#123; ARouter.getInstance().inject(this); &#125; public void sayHello() &#123; helloSerice.say; &#125;&#125; 该代码本身并没有问题，问题出在在 android 开发中我们需要混淆代码，大家还记得之前讲的 AutowiredService 的实现吧，关键代码在这里， 123if (null == autowiredHelper) &#123; // No cache. autowiredHelper = (ISyringe) Class.forName(instance.getClass().getName() + SUFFIX_AUTOWIRED).getConstructor().newInstance(); // $$ARouter$$Autowired = $$ARouter$$Autowired&#125; 本来 ARouter 构建的类名应该是 HelloHolder$$ARouter$$Autowired, 然后实例化该对象，调用该对象的 #inject方法，可是你现在将 HelloHolder混淆成了H,导致创建对象失败，这就是你为什么在代码中调用了 ARouter.getInstance().inject(this)，但是 service 还是为 null 的原因 在 android 开发中，Activity，Fragment 我们在混淆规则中是配置了 keep 等规则的，所以不会有问题。但是像上文中 HelloHolder 这种情况常常被我们所忽略，在开发中一定要注意，建议采用注解方式来保持类名不被混淆。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Alibaba</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 开发之 APT 技术]]></title>
    <url>%2Fblog%2F2019%2F01%2F04%2FAndroid-%E5%BC%80%E5%8F%91%E4%B9%8B-APT-%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[APT，就是Annotation Processing Tool 的简称，就是可以在代码编译期间对注解进行处理，并且生成Java文件，减少手动的代码输入。一些大名鼎鼎的框架如 Retrofit, Arouter 都运用了 APT 技术。 在本片文章中我们将利用 APT 技术实现类似 ARouter 的路由功能. 不多说，先附上本文中的代码地址：APTdemo https://github.com/square/javapoet 实现效果常用的 Activity 跳转方式： 1startActivity(new Intent(MainActivity.this, TwoActivity.class)); 我们希望通过以下方式达到 Activity 跳转的目的： 1SRouter.getInstance().navigate(MainActivity.this, "router_two"); 注解创建annotationlibrary, 首先我们在 library 中定义注解，通过它我们可以找到哪些 Activity 需要添加到路由中 12345@Retention(RetentionPolicy.CLASS)@Target(ElementType.TYPE)public @interface Router &#123; String name();&#125; 注解处理器 - compile创建compilelibrary,依赖 annotation模块， 注意创建的时候选择 java-libray， 创建RouterProcessor类继承自 AbstractProcessor。我们需要实现 4 个方法，前3个方法简单的写法很固定，简单讲一下他们的作用吧； init()方法可以初始化拿到一些使用的工具，比如文件相关的辅助类 Filer;元素相关的辅助类Elements;日志相关的辅助类Messager; getSupportedSourceVersion()方法返回 Java 版本; getSupportedAnnotationTypes()方法返回要处理的注解； 其中最核心的是 process()方法，通过javapoet 再结合注解我们就可以成相应的类。 最终我们希望生成的类是这样的： 1234567891011public final class Router$$GroupApp implements IRouterGroup &#123; private Map&lt;String, String&gt; routeMap = new HashMap(); public Router$$GroupApp() &#123; this.routeMap.put("router_two", "com.slyser.aptdemo.TwoActivity"); &#125; public String getActivityName(String routeName) &#123; return null != this.routeMap &amp;&amp; !this.routeMap.isEmpty() ? (String)this.routeMap.get(routeName) : ""; &#125;&#125; 实现代码并不复杂，就是写起来很繁琐，还好 javapoet 为我们省了不少事。 注册注解处理器编译的时候 JVM 怎么找到我们自定义的注解处理器？这个时候就要用到 SPI 机制。简单的用法就是在 compile 模块下新建 resources/META-INF/services 文件，创建这个文件很容易出错，大家可以使用 google 出品的 auto-service，通过注解就可以很方便的问我们创建相应的文件 添加auto-service的 gradle 依赖:implementation ‘com.google.auto.service:auto-service:1.0-rc3’ 核心库 - api创建 api library, 该库很简单，就只有 SRouter 一个类，核心就是反射创建注解处理器生成的对象，拿到 Activity 的 Class，完成 activity 的跳转. 使用在 Activity 上添加注解12@Router(name = "router_two")public class TwoActivity extends AppCompatActivity 跳转1SRouter.getInstance().navigate(this, "router_two"); 这样一个简单的路由跳转就完成了 总结APT技术其实就是自定义注解和注解处理器，在编译期间生成Java文件，类似于IOC控制反转，可以方便的进行解耦，在多模块开发时可以基于APT技术构造一套路由框架，去除startActivity等造成的类依赖。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>APT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPI 介绍与使用]]></title>
    <url>%2Fblog%2F2019%2F01%2F04%2FSPI-%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介SPI全称是Service Provider Interface，服务提供方接口，服务通常是指一个接口或者一个抽象类，服务提供方是对这个接口或者抽象类的具体实现，由第三方来实现接口提供具体的服务。SPI提供了一种动态的对应用程序进行扩展的机制，通常用作框架服务的拓展或者可替换的服务组件。 SPI机制 在resources/META-INF/services/目录中创建以服务全限定名命名的文件，该文件内容为服务的具体实现类的全限定名，文件中可以写多个服务的具体实现类 使用ServiceLoader类动态加载服务的具体实现类 服务具体的实现类必须有一个不带参数的构造方法 使用定义接口或抽象类123public interface MessageService &#123; String getMessage();&#125; 实现接口123456public class AMessageService implements MessageService &#123; @Override public String getMessage() &#123; return "Hello from module A"; &#125;&#125; 123456public class BMessageService implements MessageService &#123; @Override public String getMessage() &#123; return "Welcome from b"; &#125;&#125; 创建 SPI 描述文件如下图所示，注意目录结构: 可以使用 google 推出的 auto-service，它可以方便的帮我们生成对应的描述文件，用法很简单 使用 auto-service: 依赖 implementation &#39;com.google.auto.service:auto-service:1.0-rc3&#39; 在 Service 实现类使用注解 @AutoService 1234567@AutoService(MessageService.class)public class BMessageService implements MessageService &#123; @Override public String getMessage() &#123; return "Welcome from b"; &#125;&#125; 调用具体服务使用ServiceLoader去加载具体服务类，然后遍历具体的实现类，ServiceLoader其实就是去META-INFO/services目录下读取文件内容，然后实例化。 1234ServiceLoader&lt;MessageService&gt; serviceServiceLoader = ServiceLoader.load(MessageService.class);for (MessageService messageService : serviceServiceLoader) &#123; Log.d("auto service", "msg:" + messageService.getMessage());&#125; 优点只提供服务接口，具体服务由其他组件实现，接口和具体实现分离，同时能够通过系统的ServiceLoader拿到这些实现类的集合，统一处理。 缺点 Java中SPI是随jar发布的，每个不同的jar都可以包含一系列的SPI配置，而Android平台上，应用在构建的时候最终会将所有的jar合并，这样很容易造成相同的SPI冲突，常见的问题是DuplicatedZipEntryException异常 读取SPI配置信息是在运行时从jar包中读取，由于apk是签过名的，在从jar中读取的时候，签名校验的耗时问题会造成性能损失 在运行时通过反射加载类实例，会造成性能损失 总结在 android 项目中几乎已经见不到 SPI 的使用了，如果想达到组件间通讯同时又减少性能损失，可以使用 APT 在编译时生产成对应的 Service，再通过依赖注入获取到 Service 的实例。不过在 APT 中我们又会使用SPI 技术，所以笔者觉得有必要先讲一下 SPI. 参考 demo]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Architecture Components]]></title>
    <url>%2Fblog%2F2019%2F01%2F04%2FAndroid-Architecture-Components%2F</url>
    <content type="text"><![CDATA[Android Architecture Components 提供从管理 UI 组件的生命周期到处理数据持久性的一系列库，来帮助您设计健壮，易测试和维护的 App。 本文将简单介绍 Lifcycle, LiveData, ViewModel 的使用并对一些重要的源码进行分析 集成请参阅官方文档 在项目中添加组件 Lifecycle介绍 假设我们这里有一个具有生命周期的组件 A (例如 Activity 或 Fragment)，而另一个组件 B 需要响应 A 组件的生命周期，传统的方式是在组件 A 的生命周期依赖组件 B，但是这种方式导致代码健壮性较低，同时易导致一系列的错误。使用 Lifecycle 组件，您可以将组件 B 的代码从组件 A 的生命周期方法中移到组件本身 Lifecycle 的使用以 MyLocationManager 为例,添加相关生命周期的注解。 1234567891011121314151617class MyLocationManager : LifecycleObserver &#123; @OnLifecycleEvent(ON_CREATE) fun onCreate() &#123; glog("location onCreate") &#125; @OnLifecycleEvent(ON_START) fun onStart() &#123; glog("locatoin onstart") &#125; @OnLifecycleEvent(ON_DESTROY) fun onDestroy() &#123; glog("locatoin ondestory") &#125;&#125; 然后创建 MyLocationManager 实例，然后就可以监听到 Activity 或 Fragment 的生命周期变化。 123456override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val locationManager = LocationManager() lifecycle.addObserver(locationManager)&#125; addObserver 这个方法有一个小细节需要注意一下： 123456789101112/** * Adds a LifecycleObserver that will be notified when the LifecycleOwner changes * state. * &lt;p&gt; * The given observer will be brought to the current state of the LifecycleOwner. * For example, if the LifecycleOwner is in &#123;@link State#STARTED&#125; state, the given observer * will receive &#123;@link Event#ON_CREATE&#125;, &#123;@link Event#ON_START&#125; events. * * @param observer The observer to notify. */@MainThreadpublic abstract void addObserver(@NonNull LifecycleObserver observer); 如果 LifecycleOwner 当前的状态是 STATED，当我们调用 addObserver 方法时，会接收到 ON_CREATE 和 ON_START events. 以 MyLocationManager 为例说明，当我们在 Activity 的 onResume 方法中 addObserver 时，MyLocationManager 仍然会执行 onCreate 和 onStart 方法. UML 类图 Event and StateEven 和 State 是 Lifecycle 中很重要的概念，结合自己的代码与 google 官方的配图相信应该很容易理解. 关键源码我们在查看源码时发现 Lifecycle 只在 Activity 的 onSaveInstanceState 中 调用了 mLifecycleRegistry.markState(Lifecycle.State.CREATED) 方法，在其他生命周期中并没有 Lifecycle 的相关代码，那 support 库中是怎么做到 disptch event 的呢？ 原来在 onCreate 中有一行关键代码，它创建了一个不可见的 fragment 去分发 event 1ReportFragment.injectIfNeededIn(this); 12345678910111213141516 @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); dispatchCreate(mProcessListener); dispatch(Lifecycle.Event.ON_CREATE); &#125;... @Override public void onDestroy() &#123; super.onDestroy(); dispatch(Lifecycle.Event.ON_DESTROY); // just want to be sure that we won't leak reference to an activity mProcessListener = null; &#125; 思考一下 google 为什么要采用这样的方式，而不是直接在 Activity 的生命周期去直接分发 event 呢？以刚才的 MyLocationManager 为例, 如果打印 Activity 和 MyLocationManager 的完整生命周期日志，会得到以下结果:12345678910 05-25 06:59:17.382 32431-32431/com.slyser.arc D/arc: activity onCreate location onCreate05-25 06:59:17.385 32431-32431/com.slyser.arc D/arc: activity onStart location onStart05-25 06:59:17.386 32431-32431/com.slyser.arc D/arc: activity onResume location onResume05-25 06:59:36.675 32431-32431/com.slyser.arc D/arc: location onStop activity onStop location onDestroy05-25 06:59:36.676 32431-32431/com.slyser.arc D/arc: activity onDestroy 可以看到进入 Activity 时的执行顺序: Activity -&gt; MyLocationManager.退出 Activity 时的执行顺序刚好相反: MyLocationManager -&gt; Activity.而直接在 Activity 的生命周期中直接分发 event 是达不到这种效果的。 LiveData介绍 LiveData 是一个可观察的数据持有者。与常规可观察性不同，LiveData 具有生命周期感知能力，这意味着它尊从其他应用程序组件（例如 Activity, Fragment, Service）的生命周期。 这种设计确保 LiveData 只更新处于活动生命周期状态的应用程序组件观察者。如果观察者的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会将观察者视为活动状态。LiveData 仅将更新通知给活跃的观察者，未注册和非活动的观察者不会收到有关更新的通知。 LiveData 的使用首先我们先创建一个 LiveData,然后一个简单的方法调用，我们在监听数据变化时传入了两个参数，前者 owner 用于将 livedata 与生命周期绑定，后者监听数据的变化，这样你就能使用 LiveData 了 1public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer) 1234567891011121314class MainActivity : AppCompatActivity() &#123; val liveData = MutableLiveData&lt;Person&gt;() override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) liveData.observe(&#123;this@MainActivity.lifecycle&#125;, &#123; it?.let &#123; glog(it.name) &#125; &#125;) findViewById&lt;Button&gt;(R.id.btn).setOnClickListener &#123; liveData.value = Person("zhangsan") &#125; &#125; data class Person(var name:String)&#125; 关键源码之前介绍概念中有一段这样的话很重要: 如果观察者的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会将观察者视为活动状态。LiveData 仅将更新通知给活跃的观察者。 怎么理解这段话呢，执行如下代码，看下日志的打印内容： 12345678910111213141516171819class MainActivity : AppCompatActivity() &#123; private val person : Person = Person("live data onCreate") val liveData = MutableLiveData&lt;Person&gt;() override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) liveData.observe(&#123;this@MainActivity.lifecycle&#125;, &#123; it?.let &#123; glog(it.name) &#125; &#125;) liveData.value = person &#125; override fun onStart() &#123; super.onStart() person.name = "live data onStart" &#125; data class Person(var name:String)&#125; 日志打印出的 name 是 live data onStart, 在 onCreate 方法中明明改变了 LiveData 的值，为什么打印的 name 不是 live data onCreate 呢？ 原来我们在虽然在 onCreate 中调用了 setValue 方法，但是此时 LiveData 的 active 状态为 false 并不会通知数据变化. 1234567@MainThread protected void setValue(T value) &#123; assertMainThread("setValue"); mVersion++; // 管理数据变化的版本 mData = value; dispatchingValue(null); &#125; 12345678910111213141516171819private void dispatchingValue(@Nullable ObserverWrapper initiator) &#123; ... do &#123; mDispatchInvalidated = false; if (initiator != null) &#123; considerNotify(initiator); initiator = null; &#125; else &#123; for (Iterator&lt;Map.Entry&lt;Observer&lt;T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123; considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) &#123; break; &#125; &#125; &#125; &#125; while (mDispatchInvalidated); mDispatchingValue = false;&#125; 1234567891011private void considerNotify(ObserverWrapper observer) &#123; if (!observer.mActive) &#123; // 在 onCreate 中此时的活动状态为 false return; &#125;... if (observer.mLastVersion &gt;= mVersion) &#123; return; //active 状态变化了，但是数据版本没有增加，不会调用 onChange &#125; observer.mLastVersion = mVersion; observer.mObserver.onChanged((T) mData);&#125; 然后当 Activity 的生命执行到 onStart 后，此时 active 状态变化为 true，最终调用 observer.mObserver.onChanged((T) mData)，通知 LiveData 数据变化，但此时 person 的 name 已经变为 live data onStart 了. 123456789void activeStateChanged(boolean newActive) &#123; if (newActive == mActive) &#123; return; &#125; ... if (mActive) &#123; dispatchingValue(this); &#125; &#125; TransformationsTransformations 可以让 LiveData 在不同数据类型间进行变换，相关代码如下: 1234567891011 LiveData userLiveData = ...; LiveData userName = Transformations.map(userLiveData, user -&gt; &#123; return user.firstName + " " + user.lastName &#125;);MutableLiveData userIdLiveData = ...; LiveData userLiveData = Transformations.switchMap(userIdLiveData, id -&gt; repository.getUserById(id)); void setUserId(String userId) &#123; this.userIdLiveData.setValue(userId); &#125; ViewModel介绍 ViewModel 目的在于以生命周期的形式存储和管理与 UI 相关的数据。 ViewModel 允许数据在配置变化（例如屏幕旋转）后仍然存活。 生命周期 ViewModel 的使用ViewModel 的使用很简单，创建一个类继承 ViewModel 123class UserViewModel : ViewModel() &#123; &#125; 如果你想在 ViewModel 中使用 Context，可以继承 AndroidViewModel,然后通过一行代码即可得到 ViewModel 对象 1val viewModel = ViewModelProviders.of(this).get(UserViewModel::class.java) 关键源码首先看ViewModelProviders.of的相关代码 12345678910@NonNull @MainThread public static ViewModelProvider of(@NonNull FragmentActivity activity, @Nullable Factory factory) &#123; Application application = checkApplication(activity); if (factory == null) &#123; factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application); &#125; return new ViewModelProvider(ViewModelStores.of(activity), factory); &#125; ViewModelProviders.of 创建了一个 ViewModelProvider 对象，ViewModelProvider 构造方法传递两个参数 ViewModelStore 和 Factory ，Factory 很简单，就是让你自己决定如何创建 ViewModel，如果 factory 为 null 则使用 android 提供的默认实现，ViewModelStore 简单来说就是个存放 ViewModel 对象的 map，key 默认为类名. 12345678@NonNull @MainThread public static ViewModelStore of(@NonNull FragmentActivity activity) &#123; if (activity instanceof ViewModelStoreOwner) &#123; return ((ViewModelStoreOwner) activity).getViewModelStore(); &#125; return holderFragmentFor(activity).getViewModelStore(); // 兼容27.1.0以下版本的 support 库 &#125; 其中ViewModelStoreOwner是一个接口，只有一个方法，在 27.1.0 的 FragmentActivity 已经实现了该接口 1ViewModelStore getViewModelStore(); 27.1.0 以下的版本 google 则通过创建一个不可见的实现 ViewModelStoreOwner接口的 fragment 去做兼容，以下是相关关键代码 12345678910111213141516171819HolderFragment holderFragmentFor(FragmentActivity activity) &#123; FragmentManager fm = activity.getSupportFragmentManager(); HolderFragment holder = findHolderFragment(fm); if (holder != null) &#123; return holder; &#125; holder = mNotCommittedActivityHolders.get(activity); if (holder != null) &#123; return holder; &#125; if (!mActivityCallbacksIsAdded) &#123; mActivityCallbacksIsAdded = true; activity.getApplication().registerActivityLifecycleCallbacks(mActivityCallbacks); //注册生命周期，activity 销毁时将 HolderFragment 从 mNotCommittedActivityHolders 移除 &#125; holder = createHolderFragment(fm); mNotCommittedActivityHolders.put(activity, holder); return holder;&#125; 搞清楚了ViewModelStore再回过头来看ViewModelProvider的 get 方法 1234567891011121314151617181920@NonNull @MainThread public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; ViewModel viewModel = mViewModelStore.get(key); // mViewModelStore为构造方法传递 if (modelClass.isInstance(viewModel)) &#123; //store 中存储了 ViewModel 则直接返回 //noinspection unchecked return (T) viewModel; &#125; else &#123; //noinspection StatementWithEmptyBody if (viewModel != null) &#123; // TODO: log a warning. &#125; &#125; viewModel = mFactory.create(modelClass); //store 中没有 ViewModel 则创建一个 ViewModel，并在 ViewModelStore 中的 map 中存放 mViewModelStore.put(key, viewModel); //noinspection unchecked return (T) viewModel; &#125; 总结一下: 如果使用的 support 库为 27.1.0 以上则 Activity 和 Fragment 都实现了 ViewModelStoreOwner 接口，提供ViewModelStore实例 如果使用的 support 库为 27.1.0 以下，则会创建一个 HolderFragment，同样实现了 ViewModelStoreOwner 接口，提供ViewModelStore实例 ViewModelStore本质是默认 key 为类名 value 为 ViewModel 的 map 在 fragment 间共享数据我们在不同的 fragment 中调用 ViewModelProviders.of() 时，如果参入的参数为 activity，则获取的 ViewModel 对象为同一实例，代码如下： 1val viewModel = ViewModelProviders.of(getActivity()).get(UserViewModel::class.java) 这样我们就可以在两个或更多 fragment 间彼此间进行通信。 最佳实践 尽可能保持您的 UI 控制器（activity 和 fragment）精简。他们不应该试图获取他们自己的数据;相反，使用 ViewModel 来做到这一点，并通过监听 LiveData 对象来更新视图。 尝试编写数据驱动的用户界面，其中您的 UI 控制器的职责是在数据更改时更新视图，或将用户操作通知给ViewModel。 把你的数据逻辑放在 ViewModel 类中。 ViewModel 应作为您的 UI 控制器和其他应用程序之间的连接器。 但要小心，ViewModel 不负责提取数据（例如，来自网络）。 相反，ViewModel 应调用相应的组件来获取数据，然后将结果提供给UI控制器 使用 Data Binding 在视图和 UI 控制器之间保持干净的界面。 这可以使您的视图更具说明性，并最大限度地减少需要在 activity 和 fragment 中编写的更新代码。 如果你喜欢用 java 编程语言来做到这一点，可以使用像 Butter Knife 这样的库来避免样板代码并且能够更好的抽象。 如果您的 UI 很复杂，请考虑创建一个 presenter 来处理 UI 修改。这可能是一项艰巨的任务，但它可以使您的 U I组件更易于测试。 避免在 ViewModel 中引用 View 或 Activity 上下文。如果 ViewModel 存活的时间比 Activity（在配置更改的情况下），将会造成 activity 的内存泄漏]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[All categories]]></title>
    <url>%2Fblog%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[All tags]]></title>
    <url>%2Fblog%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
