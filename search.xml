<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[flutter state layout]]></title>
    <url>%2Fblog%2F2020%2F01%2F03%2Fflutter-state-layout%2F</url>
    <content type="text"><![CDATA[flutter state layout前言在 app 中我们经常会遇到这样的场景，进入页面时先发起网络请求从后台获取数据，此时应显示 loading 界面，待数据返回时显示正常的界面，如果发生了网络异常还需要显示 error 界面，并且具有点击重试的机制。 针对这样的场景我们肯定希望能封装一个 widget 来满足这样的需求，在这里分享一个我的 flutter 项目中的 state_layout给大家。 Future BuilderFutureBuilder是官方提供的一个 widget，具体使用可以去查看官方文档。 Widget that builds itself based on the latest snapshot of interaction with a Future. 我的这个控件就是基于 FutureBuilder 实现的。 视图View12345678910111213141516171819202122232425262728293031323334353637class LoadingLayout extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return SizedBox.expand( child: Center( child: SizedBox(width: 40, height: 40, child: CircularProgressIndicator()), )); &#125;&#125;class EmptyLayout extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return SizedBox.expand( child: Center( child: Text('-暂无数据-'), )); &#125;&#125;class ErrorLayout extends StatelessWidget &#123; final String errorInfo; final VoidCallback onError; ErrorLayout(&#123;this.errorInfo = '出错了!', this.onError&#125;); @override Widget build(BuildContext context) &#123; return SizedBox.expand( child: Center( child: GestureDetector( onTap: onError, child: Text(errorInfo ?? '出错了!'), ), ), ); &#125;&#125; 视图 View 的代码很简单，其中错误视图我们需要给它一个点击事件，使它具有重新请求网络的功能。 核心代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859typedef SucViewBuilder&lt;T&gt; = Widget Function(T data);typedef FutureFuc&lt;T&gt; = Future&lt;T&gt; Function();class StateLayout&lt;T&gt; extends StatefulWidget &#123; StateLayout(&#123;@required this.future, @required this.builder, this.contoller&#125;); final FutureFuc&lt;T&gt; future; final SucViewBuilder&lt;T&gt; builder; final StateLayoutContoller contoller; @override _StateLayoutState createState() =&gt; _StateLayoutState&lt;T&gt;();&#125;class _StateLayoutState&lt;T&gt; extends State&lt;StateLayout&lt;T&gt;&gt; &#123; Future _future; @override void initState() &#123; super.initState(); _future = widget.future(); &#125; @override Widget build(BuildContext context) &#123; return FutureBuilder&lt;T&gt;( // 这里为什么不直接使用 widget.future() future: _future, builder: (context, snap) &#123; if (snap.connectionState == ConnectionState.done) &#123; if (snap.hasError) &#123; final error = snap.error; return ErrorLayout( onError: onError, errorInfo: (error is Exception) ? error.toString() : null, ); &#125; else if (snap.hasData &amp;&amp; snap.data != null) &#123; return widget.builder(snap.data); &#125; else &#123; return EmptyLayout(); &#125; &#125; else if (snap.connectionState == ConnectionState.waiting) &#123; return LoadingLayout(); &#125; else &#123; return ErrorLayout( onError: onError, ); &#125; &#125;, ); &#125; void onError() &#123; setState(() &#123; _future = widget.future(); &#125;); &#125;&#125; 核心代码基本是参照FutureBuilder的官方代码，这里需要特别注意的是FutureBuildler的参数使用的是成员变量 _future 而不是widget.future()。 在 flutter 中 StateFullWidget的 build方法会在父组件调用 setState或父组件视图树发生变化（比如页面跳转）时调用， build方法多次调用会导致多次闯将 Future实例，在 FutureBuild中则通过对比新旧 future是否相同来订阅 future。 1234567891011@override void didUpdateWidget(FutureBuilder&lt;T&gt; oldWidget) &#123; super.didUpdateWidget(oldWidget); if (oldWidget.future != widget.future) &#123; if (_activeCallbackIdentity != null) &#123; _unsubscribe(); _snapshot = _snapshot.inState(ConnectionState.none); &#125; _subscribe(); &#125; &#125; 所以为了避免出现重复的网络请求和视图变化，所以这里只能使用成员 _future。 到这里核心功能已经完成了，有时我们需要主动去请求网络更新数据，碰到这种情况我们只需要给 StateLayout增加一个 Controller即可，代码如下： 12345678910111213141516171819202122232425262728class StateLayoutContoller &#123; Function refresh; void callRefresh() &#123; refresh(); &#125;&#125;class StateLayout&lt;T&gt; extends StatefulWidget &#123;// 增加 controller StateLayout(&#123;@required this.future, @required this.builder, this.contoller&#125;);&#125;class _StateLayoutState&lt;T&gt; extends State&lt;StateLayout&lt;T&gt;&gt; &#123; void initState() &#123; super.initState(); _future = widget.future(); // 初始化 controller if (widget.contoller != null) &#123; widget.contoller.refresh = _refresh; &#125; &#125; void _refresh() &#123; setState(() &#123; _future = widget.future(); &#125;); &#125;&#125; 使用123456789101112131415161718192021@overrideWidget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('state layout'), ), body: StateLayout&lt;int&gt;( future: _fetchData, builder: (count) &#123; return Text('数量是: $count'); &#125;, ), );&#125;Future&lt;int&gt; _fetchData() async &#123; await Future.delayed(Duration(seconds: 2)); print('fetch data'); return 1;&#125; 可以看到整个代码很简洁，不需要处理异常，不需要主动去显示 loading 视图或成功视图。最后，本文中的示例代码可以在我的 github上找到。]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 记一次打开应用后的通病]]></title>
    <url>%2Fblog%2F2019%2F07%2F17%2Fandroid-%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%89%93%E5%BC%80%E5%BA%94%E7%94%A8%E5%90%8E%E7%9A%84%E9%80%9A%E7%97%85%2F</url>
    <content type="text"><![CDATA[现象描述app 在应用市场下载完成后，点击打开，按照 app 的一般流程首先会启动 Splash 界面，再进入首页。此时你按下 home 键，再从桌面点击应用图标，你会发现应用又走到了 Splash 界面再进入首页。再次按 home 键重复刚才的动作现象依旧，通过将应用结束或杀掉进程应用就会恢复正常。当然这种现象理论上来说在你安装完应用后只会出现一次，但终归还是会影响用户体验。(如果用户进入了比较深层次的页面,这个体验对用户来说绝对是个灾难) 大家可以去随便下一款 app 试一下，大概率会有这种现象。大厂 app 就不要试了，别人早就处理好了这个问题。所以先看一下网易和 b站是怎么解决这个问题的。 解决方案我们先来看网易的解决办法 12345678910111213141516171819202122232425262728293031paramJoinPoint = paramAdActivity.getIntent();int k = 0;int i;if ((paramJoinPoint != null) &amp;&amp; (paramAdActivity.getIntent().getBooleanExtra("out", false))) &#123; i = 1;&#125; else &#123; i = 0;&#125;long l = System.currentTimeMillis();paramAdActivity.setTheme(2131689487);int j = k;if (!paramAdActivity.isTaskRoot()) // 关键代码1&#123; j = k; if (paramAdActivity.getIntent() != null) &#123; j = k; if ((paramAdActivity.getIntent().getFlags() &amp; 0x400000) != 0) &#123; // 关键代码 2 j = 1; &#125; &#125;&#125;if (j == 0) &#123; fp.a(paramAdActivity.getIntent(), AdFragment.class.getName(), "AdFragment", null);&#125;paramAdActivity.onCreate(paramBundle);if (j != 0)&#123; paramAdActivity.finish(); return;&#125; 核心逻辑如下 123456if(!isTaskRoot) &#123; if((getIntent().getFlags() &amp; Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT) != 0) &#123; finish(); return; &#125;&#125; 1234567/** * This flag is not normally set by application code, but set for you by * the system as described in the * &#123;@link android.R.styleable#AndroidManifestActivity_launchMode * launchMode&#125; documentation for the singleTask mode. */public static final int FLAG_ACTIVITY_BROUGHT_TO_FRONT = 0x00400000; 接着是 B 站的： 12345678910111213Object localObject; if ((m.a.a((Context)this)) &amp;&amp; (!isTaskRoot())) &#123; localObject = getIntent(); Intrinsics.checkExpressionValueIsNotNull(localObject, "intent"); localObject = ((Intent)localObject).getAction(); if ((getIntent().hasCategory("android.intent.category.LAUNCHER")) &amp;&amp; (TextUtils.equals((CharSequence)localObject, (CharSequence)"android.intent.action.MAIN"))) &#123; m.a.b((Context)this); b(); // 调用 finish() return; &#125; &#125; 核心逻辑如下： 123456if(!isTaskRoot()) &#123; if ((getIntent().hasCategory(Intent.CATEGORY_LAUNCHER)) &amp;&amp; (TextUtils.equals(getIntent().getAction(), Intent.ACTION_MAIN)) &#123; finish(); return &#125;&#125; 总结两种方案的逻辑判断都很简单，且前置条件都是先判断 isTaskRoot，差异在于后续的判断处理，就我个人而言觉得 b 站的方案更易于理解。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter 中的 State]]></title>
    <url>%2Fblog%2F2019%2F04%2F04%2Fflutter-%E4%B8%AD%E7%9A%84-State%2F</url>
    <content type="text"><![CDATA[Declarative UI 和 Imperative UI在 Flutter 中的 UI 采用的是 Declarateve 风格，即声明式 UI，而在我们以往的 Android 开发中的 UI 采用的是 Impreative 风格，即命令式 UI。我们来看一个两种风格对比的例子。 12345// Declarative stylereturn ViewB( color: red, child: ViewC(...),) 12345// Imperative styleb.setColor(red)b.clearChildren()ViewC c3 = new ViewC(...)b.add(c3) 如果你想要改变 ViewB 的颜色，或者是隐藏或显示 ViewC，Impretive style 是通过类似 findViewById()的方法找到该 View，调用该 View 的 set 方法。但是在 Declarateve style 中 View 的属性是不可变的，你只能通过改变 View 的 setState方法来触发 View 的重新创建与绘制。 在 Flutter 中将 View 称之为 Widget，分为 StatelessWidget 和 StatefulWidget。只有后者才能调用 setState方法。 官方文档中将 flutter 的 state 分为了 ephemeral state 和 app state Ephemeral stateephemeral state又可以称为 local state 或 ui state，通常是该状态只在 widget 中有效。widget tree 的其他部分很少需要访问这种状态，所以没有必要对其进行序列化，并且它不会以复杂的方式发生变化。在 flutter 中要使用 state，你只需要使用 StatefullWidget即可，举个例子： 123456789101112131415class MyHomepage extends StatefulWidget &#123; @override _MyHomepageState createState() =&gt; _MyHomepageState();&#125;class _MyHomepageState extends State&lt;MyHomepage&gt; &#123; int _count = 0; @override Widget build(BuildContext context) &#123; return Text( 'count:$_count', ); &#125;&#125; App state平时在开发中我们进场需要在在多个 widget，甚至是整个 App 都需要共享的状态的情景。在上一个 Ephemral state例子上扩展一下，假设有一个页面叫做 SecondPage，页面中有一个按键，通过点击按键需要增加 MyHomepage中 count 的计数。在 android 中碰到这种场景我们一般会想到回调。 在上文中我们已经提到了，在 Flutter 的 Decalarateve style 决定了它不可能出现类似 android 中实例化某个组件，然后调用 setCallback的代码。虽然我们依然可以在构造参数中传递 Callback，但是解决不了跨多个 Widget 的问题。 所以在 Flutter 中 为我们提供了全局的 state，通过修改 state 来改变与该 state 相关的所有视图。使用方式也很简单： 首先在 pubspec.yaml中添加scoped_model: ^1.0.0依赖 创建CountModel继承Model 12345678class CountModel extends Model &#123; int count = 0; increaseCount() &#123; count++; notifyListeners(); &#125;&#125; 在入口main方法中注册该 Model 12345678void main() &#123; final count = CountModel(); runApp(ScopedModel&lt;CountModel&gt;(model: count, child: MaterialApp( home: MyApp(), )));&#125;/// 这里ScopedModel继承至StatelessWidget，传入的 child 是 CountModel /// 的作用域。 获取该 Model对象并使用 12345678910111213141516171819... /// 1 floatingActionButton: FloatingActionButton( onPressed: () &#123; ScopedModel.of&lt;CountModel&gt;(context).increaseCount(); &#125;, child: Icon(Icons.add), )...... /// 实际上 ScopedModelDesendata 核心代码仍然是 ScopeModel.of(context) body: Center( child: ScopedModelDescendant&lt;CountModel&gt;( builder: (context, _, count) &#123; return Text('the count is:$&#123;count.count&#125;'); &#125;, ), )... Flutter ReduxApp State 为我们提供了一种共享状态的方式，那还有没有其他可应用在复杂应用的方式呢？接触过前端的同学应该了解共享状态方面的大杀器 Redux，在 Flutter 中也有 Redux 的实现。 我们以官方的 Demo来说明，首先看一下大致的项目结构： 在这个项目中我们的 AppState 需要保存用户信息和商品列表，AppState 如下所示： 12345class AppState &#123; final User user; final List&lt;Good&gt; inCartGoods; AppState(&#123;this.user = const User(name: "", password: ""), this.inCartGoods = const []&#125;);&#125; login 和 cata 目录下的 states.dart 和 actions.dart代码也很简单： 123456789101112131415161718192021222324252627282930313233/// stateclass Good &#123; final String name; final String price; final String id; bool isInCart; Good(&#123;this.name, this.price, this.id, this.isInCart = false&#125;); @override int get hashCode =&gt; id.hashCode; @override bool operator ==(other) &#123; return other is Good &amp;&amp; other.id == id; &#125; changeInCart(bool inCart) &#123; isInCart = inCart; &#125;&#125;/// enum Actions &#123; ADD, REMOVE&#125;class ChangeGoodAction &#123; ChangeGoodAction(&#123;this.id, this.action&#125;); final String id; final Actions action;&#125; 关键就在于 reducers.dart 12345678910111213final cataReducers = combineReducers&lt;List&lt;Good&gt;&gt;([ TypedReducer&lt;List&lt;Good&gt;, ChangeGoodAction&gt;(_switchGoodInCart),]);List&lt;Good&gt; _switchGoodInCart(List&lt;Good&gt; goods, ChangeGoodAction action) &#123; Good changeGood = Good(id: action.id); final index = goods.indexOf(changeGood); if(index == -1) &#123; return goods; &#125; goods[index].changeInCart(action.action == Actions.ADD); return goods;&#125; 时刻牢记，reducer 是一个 fuction，它返回的是一个 State 对象，接受两个参数 State 对象和 Action。 同样的 login 下也有一个 loginReducer,接下来我们需要将构建一个 appReducers，代码如下： 123456AppState appReducers(AppState state, action) &#123; return AppState( user: loginReducers(state.user, action), inCartGoods: cataReducers(state.inCartGoods, action) );&#125; 最后就是在程序入口初始化 store,代码如下： 123456789101112131415161718final store = Store&lt;AppState&gt;( appReducers, initialState: AppState(inCartGoods: _processItems()), ); return StoreProvider&lt;AppState&gt;( store: store, child: MaterialApp( initialRoute: '/', routes: &#123; '/cata': (context) =&gt; CataLog() &#125;, theme: ThemeData( primarySwatch: Colors.yellow, primaryColor: Colors.yellow, ), home: LoginScreen(), ), ); 到这一步我们redux的结构算是搭建完成了，剩下的就是如何在视图中使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class CataItem extends StatelessWidget &#123; CataItem(&#123;Key key, this.index&#125;) : super(key: key); final int index; @override Widget build(BuildContext context) &#123; return Padding( padding: const EdgeInsets.all(8.0), // 由于 FlatButton 同时需要商品的信息和回调方法，所以在这里封装了一层 child: StoreConnector&lt;AppState, _Wrapper&gt;( converter: (store) &#123; var good = store.state.inCartGoods[index]; return _Wrapper( good: good, callback: () =&gt; store.dispatch(ChangeGoodAction( id: good.id, action: good.isInCart ? Actions.REMOVE : Actions.ADD))); &#125;, builder: (context, wrapper) &#123; return Row( children: &lt;Widget&gt;[ Container( decoration: BoxDecoration( color: Colors.primaries[index % Colors.primaries.length]), width: 20.0, height: 20.0, ), Expanded( child: Padding( padding: const EdgeInsets.symmetric(horizontal: 8.0), child: Text(wrapper.good.name), ), ), FlatButton( child: wrapper.good.isInCart ? Icon(Icons.check) : Text('ADD'), onPressed: wrapper.callback, splashColor: Colors.yellow, ) ], ); &#125;, ), ); &#125;&#125;class _Wrapper &#123; _Wrapper(&#123;this.callback, this.good&#125;); final VoidCallback callback; final Good good;&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>state</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法导论-基础知识]]></title>
    <url>%2Fblog%2F2019%2F03%2F06%2F%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[算法基础分析算法插入排序 对于少量元素的排序，插入排序是一个有效的算法。插入排序的工作方式像许多人排序一副扑克牌。开始时，我们的左手为空且桌面上的牌牌面向下。然后我们每次从桌面上拿走一张牌将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右往左将它与已在手中的每一张牌进行比较，如上图所示，这样拿到手中的牌始终是排好序的，代码如下： 123456789101112fun insertionSort(arrays: Array&lt;Int&gt;)&#123; val count = arrays.size for (j in 1 until count) &#123; // C1 val target = arrays[j] // C2 var i = j -1 // C3 while (i &gt;= 0 &amp;&amp; arrays[i] &lt; target) &#123; // C4 arrays[i + 1] = arrays[i] // C5 i-- // C6 &#125; arrays[i + 1] = target // C7 &#125;&#125; 该算法的运行时间如下： T(n)=c_1n+c_2(n-1)+c_3(n-1)+c_4\sum_{j=2}^nt_j+c_5\sum_{j=2}^n(t_j-1)+c_6\sum_{j=2}^n(t_j-1)+c_7(n-1)\\ c:表示运行改行代码的代价，即执行每行代码所需要的时间\\ t_j:表示执行 while 循环的次数，在最好的情况下 t_j = 1,最坏的情况下 t_j = j最好情况（数据已经排好序）： T(n) = c_1n+c_2(n-1) + c_3(n-1) + c_4(n-1) + c_5(n-2)+c_6(n-2)+c_7(n-1)\\ =an-b最坏情况（数据逆序排序）： 其中$\sum_{j=2}^nj = {n(n+1) \over 2}-1$是一个等差数列 T(n) = c_1n+c_2(n-1)+c_3(n-1)+c_4({n(n+1)\over2}-1)+c_5({n(n-1)\over2}) + c_6({n(n-1)\over2})+c_7(n-1)\\ =an^2+bn+c可以看到插入排序在最好的情况，运行时间是一个线性函数,在最坏的情况下是一个二次函数 增长量级： 对于插入排序，当我们忽略低阶项和最重要项的常数时，只剩下最重要项的因子$n^2$。我们记插入排序的最坏运行时间为$\theta(n^2)$ 选择排序考虑存储在数组 A 中的 n 个数：首先找出 A 中的最小元素与 A[1]中的元素进行交换，接着找出A中的次最小元素并将其与A[2]中的元素进行交换，该算法被称为选择排序12345678910111213fun chooseSort(arrays: Array&lt;Int&gt;) &#123; for (i in 0 until arrays.size) &#123; var minIndex = i for (j in i until arrays.size) &#123; if (arrays[minIndex] &gt; arrays[j]) &#123; minIndex = j &#125; &#125; val tmp = arrays[i] arrays[i] = arrays[minIndex] arrays[minIndex] = tmp &#125;&#125; 该算法的运行时间为 $\theta (n^2)​$ 选择排序的关键是记录最小值的下标 冒泡排序冒泡排序是一种流行但低效率的排序算法，它的排序方法时反复交互相邻的未按次序排列的元素 1234567891011fun bubbleSort(arrays: Array&lt;Int&gt;) &#123; for (i in arrays.size - 1 downTo 0) &#123; for (j in 0 until i) &#123; if (arrays[j] &gt; arrays[j + 1]) &#123; val tmp = arrays[j] arrays[j] = arrays[j + 1] arrays[j + 1] = tmp &#125; &#125; &#125;&#125; 该算法的运行时间为$\theta (n^2) ​$ 比较插入排序，选择排序，冒泡排序，插入排序是三者中效率较高的算法，因为选择排序和冒泡排序不管数据的排序情况如何，即使是已经排好序的数组，所花费的时间仍然是$\theta(n^2)$ 设计算法分治法许多有用的算法在结构上是递归的：为了解决一个给定的问题，算法一次或多次递归调用其自身以解决紧密相关的若干问题。这些算法典型的遵循分治法的思想：将原问题分解为几个规模较小但类似原问题的子问题，递归的求解这些子问题，然后再合并这些子问题的解来建立原问题的解。 分治模式在每层递归的时候都有三个步骤： 分解原问题为若干子问题，这些子问题是原问题规模较小的实例 解决这些子问题，递归的求解各子问题，若子问题的规模足够小，则直接求解 合并这些子问题的解成原问题的解 归并排序算法完全遵循分支模式，直观上的操作如下： 分解：分解待排序的 n 个元素的序列成各具 n/2 个元素的两个子序列 解决：使用归并排序递归地排序两个子序列 合并：合并两个已排序的子序列来产生已排序的答案 下面给出归并排序的相关代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 要使该方法正常运作，需要满足一下条件： * 1. arrays[start~mid] 为有序 * 2. arrays[mid+1~end] 为有序 */fun merge(arrays: Array&lt;Int&gt;, start: Int, mid: Int, end: Int) &#123; val tmp = arrayOfNulls&lt;Int&gt;(end - start + 1) var index = 0 var leftIndex = start var rightIndex = mid + 1 while (leftIndex &lt;= mid &amp;&amp; rightIndex &lt;= end) &#123; if (arrays[leftIndex] &lt; arrays[rightIndex]) &#123; tmp[index] = arrays[leftIndex] leftIndex++ &#125; else &#123; tmp[index] = arrays[rightIndex] rightIndex++ &#125; index++ &#125; while (leftIndex &lt;= mid) &#123; tmp[index] = arrays[leftIndex] leftIndex++ index++ &#125; while (rightIndex &lt;= end) &#123; tmp[index] = arrays[rightIndex] index++ rightIndex++ &#125; tmp.forEach &#123; print("===$it===") &#125; println() System.arraycopy(tmp, 0, arrays, start, tmp.size)&#125;fun mergeSort(arrays: Array&lt;Int&gt;, start: Int, end: Int) &#123; // 跳出递归条件 if (start &lt; end) &#123; // 分解 val newMid = (end + start) / 2 // 解决: 递归排序 mergeSort(arrays, start, newMid) mergeSort(arrays, newMid + 1, end) // 合并 merge(arrays, start, newMid, end) &#125;&#125; 分析分治算法 $T(n)=\theta (nlgn)$ 其中$lgn = log_2n​$ 后记刚看完麻省理工公开课第一集，里面提到了算法导论的预备知识，包括《计算科学的数学基础》，还需要懂离散数学和概率论的基础知识以及编程知识。]]></content>
      <categories>
        <category>algorithms</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava 源码分析]]></title>
    <url>%2Fblog%2F2019%2F01%2F08%2FRxJava-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[RxJava 源码分析RxJava 定义RxJava是基于Java虚拟机上的响应式扩展库，它通过使用可观察的序列将异步和基于事件的程序组合起来。与此同时，它扩展了观察者模式来支持数据/事件序列，并且添加了操作符，这些操作符允许你声明性地组合序列，同时抽象出要关注的问题：比如低级线程、同步、线程安全和并发数据结构等。 RxJava 的订阅流程先给出一个 RxJava 最基本的订阅例子: 1234567891011121314151617181920212223242526272829Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; e.onNext("1"); e.onNext("2"); e.onNext("3"); e.onComplete(); &#125;&#125;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; System.out.println("on subscribe"); &#125; @Override public void onNext(String s) &#123; System.out.println("on next:" + s); &#125; @Override public void onError(Throwable e) &#123; System.out.println("on error:" + e); &#125; @Override public void onComplete() &#123; System.out.println("on complete"); &#125;&#125;); 这里可以看到核心的代码有两部分： 创建被观察者(Observable) 创建观察者(Observer)订阅 创建被观察者上面的代码调用 Observable#create，首先我们来看下这个方法做了什么。 1.Observable#create()1234public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; ObjectHelper.requireNonNull(source, "source is null"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; 可以看到该方法先是创建了一个 ObservableCrate对象，构建该对象时需要将参数 ObservableOnSubscribe对象传入，最后调用 RxJavaPlugins#onAssembley方法组装Observable对象并将其返回，接下来我们看下 ObservableCreate这个类。 2.ObservableCreate1234567891011121314151617181920public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123; final ObservableOnSubscribe&lt;T&gt; source; public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) &#123; this.source = source; &#125; @Override protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); observer.onSubscribe(parent); try &#123; source.subscribe(parent); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); parent.onError(ex); &#125; &#125; &#125; 该类很简单，仅仅是保存ObservableOnSubscribe对象，当然还有一个重要的方法 subscribeActual方法，看这个方法的命名，推测应该是订阅的时候调用，我们后面再分析，接着看RxJavaPlugins#onAssembly。 3.RxJavaPlugins#onAssembly12345678public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123; // 应用 hook 处理，如果你想hook函数，可以调用 RxJavaPlugins#setOnObservableAssembly Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly; if (f != null) &#123; return apply(f, source); &#125; return source;&#125; 仅仅是将 ObservableCreate对象返回。 以上就是创建观察者的整个过程，总结一下就是Observable#create将我们定义的ObservableOnSubscribe对象包装成了一个ObservableCreate对象并返回。 订阅过程接着看订阅过程是如何实现的。 1. Observable#subscribe12345public final void subscribe(Observer&lt;? super T&gt; observer) &#123; // hook observer = RxJavaPlugins.onSubscribe(this, observer); subscribeActual(observer);&#125; 关键方法是subscribeActual，它是Observable类的一个抽象方法， 接下来我们看下它在在ObservableCreate中的实现。 2.ObservableCreate#subscribeActual1234567891011121314@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; // 1 CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); // 2 observer.onSubscribe(parent); try &#123; // 3 source.subscribe(parent); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); parent.onError(ex); &#125;&#125; 在注释1处，首先创建了一个 CreateEmitter对象，同时传入了Observer对象。 123456789static final class CreateEmitter&lt;T&gt; extends AtomicReference&lt;Disposable&gt;implements ObservableEmitter&lt;T&gt;, Disposable &#123; final Observer&lt;? super T&gt; observer; CreateEmitter(Observer&lt;? super T&gt; observer) &#123; this.observer = observer; &#125; ...&#125; CreateEmitter通过继承 AtomicReference 保证了事件流切断状态DISPOSED 的一致性，并实现了 ObservableEmmiter 和 Disposaable 接口，接着看注释2处的 observer.onSubsribe(parent), 这个回调函数的意义就是告诉观察者已经成功订阅了被观察者。最后看注释3出的代码,这里的 source 实际上就是我们自定义的 ObservableOnSubscribe对象,最后再看一下ObservableOnSubscribe#subscribe方法 12345678910Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; System.out.println(Thread.currentThread()); e.onNext("1"); e.onNext("2"); e.onNext("3"); e.onComplete(); &#125; &#125;) 这里面使用到了ObservableEmitter的onNext()方法将事件流发送出去，最后调用了onComplete()方法完成了订阅过程, ObservableEmitter是一个抽象类，其中的一个实现类就是我们传入的 CreateEmitter,接下来就开始分析 onNext&amp;onComplete方法 3.CreateEmitteronNext()&amp;onComplete()12345678910111213141516@Override public void onNext(T t) &#123; if (!isDisposed()) &#123; observer.onNext(t); &#125; &#125; @Override public void onComplete() &#123; if (!isDisposed()) &#123; try &#123; observer.onComplete(); &#125; finally &#123; dispose(); &#125; &#125; &#125; 方法很简单，先判断当前的事件流是否被切断，如果没有则执行相应的回调，接下来看下 isDisposed 方法 4.ObserverEmitter#isDisposed() 1234@Overridepublic boolean isDisposed() &#123; return DisposableHelper.isDisposed(get());&#125; 注意这里通过 get() 方法从 AtomicReference 中拿到了保存的 Disposable 状态，再交由DisposableHelper去判断，接下来看 DisposableHelper 的处理 5.DisposableHelper#isDisposed() &amp; set() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public enum DisposableHelper implements Disposable &#123; DISPOSED; public static boolean isDisposed(Disposable d) &#123; // 1 return d == DISPOSED; &#125; public static boolean set(AtomicReference&lt;Disposable&gt; field, Disposable d) &#123; for (;;) &#123; Disposable current = field.get(); if (current == DISPOSED) &#123; if (d != null) &#123; d.dispose(); &#125; return false; &#125; // 2 if (field.compareAndSet(current, d)) &#123; if (current != null) &#123; current.dispose(); &#125; return true; &#125; &#125; &#125; ... public static boolean dispose(AtomicReference&lt;Disposable&gt; field) &#123; Disposable current = field.get(); Disposable d = DISPOSED; if (current != d) &#123; // 3 current = field.getAndSet(d); if (current != d) &#123; if (current != null) &#123; current.dispose(); &#125; return true; &#125; &#125; return false; &#125; ...&#125; DisposableHelper是一个枚举类，内部只有一个值即DISPOSED, 从上面的分析可知它就是用来标记事件流切断状态的。先看到注释2和注释3处的代码field.compareAndSet(current, d)和field.getAndSet(d)，这里使用了原子引用AtomicReference内部包装的CAS(compare and swap)方法处理了标志Disposable的并发读写问题，最后看到注释1处，将我们传入的CreateEmitter这个原子引用类保存的Disposable状态和DisposableHelper内部的DISPOSED进行比较，如果相等，就证明数据流被切断了。 RxJava 线程切换在上述的例子中，我们只要添加以下代码就能方便的做到线程切换： 12.subscribeOn(Schedulers.computation()) .observeOn(Schedulers.io()) SubscribeOn1.Observerble#subsribeOn1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; 该方法首先将线程调度器和该 Observable 对象包装成了 ObservableSubscribeOn 对象，最后再调用 RxJavaPlugins.onAssembly 进行组装并返回，接下看 ObservableSubscribeOn类 2.ObservableSubscribeOn1234567891011121314151617public final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; protected final ObservableSource&lt;T&gt; source; final Scheduler scheduler; public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) &#123; super(source); this.scheduler = scheduler; &#125; @Override public void subscribeActual(final Observer&lt;? super T&gt; s) &#123; // 1 final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s); // 2 s.onSubscribe(parent); // 3 parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); &#125;&#125; 首先该类保存了 Observabel 和 Scheduler 对象，在实际订阅时，就会调用 subscribeActual 方法，在注释1处，将我们自定义的 Observer 包装成了 SubscribeOnObserver 对象，在注释2处通知观察者订阅了被观察者，在注释3处创建了一个 SubscribeTask 对象，然后调用Scheduler#schedulerDirect生成 Diposable对象。 接下来先分析 SubscribeTask。 3.ObservableSubscribeOn#SubscribeTask123456789101112final class SubscribeTask implements Runnable &#123; private final SubscribeOnObserver&lt;T&gt; parent; SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123; this.parent = parent; &#125; @Override public void run() &#123; source.subscribe(parent); &#125;&#125; SubscribeTask是ObservableSubscribeOn的内部类，它实质上就是一个任务类，在它的run方法中会执行到source.subscribe(parent)的订阅方法，这个source其实就是我们在ObservableSubscribeOn构造方法中传进来的ObservableCreate对象，接着看Scheduler#shedulerDirect方法。 4.Scheduler#schedulerDirect()1234567891011121314151617181920public Disposable scheduleDirect(@NonNull Runnable run) &#123; return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);&#125;public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) &#123; // 1 final Worker w = createWorker(); // 2 final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); // 3 DisposeTask task = new DisposeTask(decoratedRun, w); // 4 w.schedule(task, delay, unit); return task;&#125; 首先，在注释1处，会调用createWorker()方法创建一个工作者对象Worker，它是一个抽象类，这里的实现类就是IoScheduler，下面，我们看看IoScheduler类的createWorker()方法。 4.1.IOScheduler#createWorker()1234567891011121314151617181920212223242526272829final AtomicReference&lt;CachedWorkerPool&gt; pool;...public IoScheduler(ThreadFactory threadFactory) &#123; this.threadFactory = threadFactory; this.pool = new AtomicReference&lt;CachedWorkerPool&gt;(NONE); start();&#125;...@Overridepublic Worker createWorker() &#123; // 1 return new EventLoopWorker(pool.get());&#125;static final class EventLoopWorker extends Scheduler.Worker &#123; ... EventLoopWorker(CachedWorkerPool pool) &#123; this.pool = pool; this.tasks = new CompositeDisposable(); // 2 this.threadWorker = pool.get(); &#125;&#125; 首先，在注释1处调用了pool.get()这个方法，pool是一个CachedWorkerPool类型的原子引用对象，它的作用就是用于缓存工作者对象Worker的。然后，将得到的CachedWorkerPool传入新创建的EventLoopWorker对象中。重点关注一下注释2处，这里将CachedWorkerPool缓存的threadWorker对象保存起来了。 下面，我们继续分析4.Scheduler#schedulerDirect()处代码段注释2处的代码，这里又是一个关于hook的封装处理，最终还是返回的当前的Runnable对象。在注释3处新建了一个可切断任务DisposeTask将decoratedRun和w包装了起来。最后在注释4处调用了工作者的schedule()方法。下面我们来分析下它内部的处理 4.2.IoScheduler#scheduler()123456@Overridepublic Disposable schedule(@NonNull Runnableaction, long delayTime, @NonNull TimeUnit unit)&#123; ... return threadWorker.scheduleActual(action,delayTime, unit, tasks);&#125; 内部调用了threadWorker的scheduleActual()方法，实际上是调用到了父类NewThreadWorker的scheduleActual()方法，我们继续看看NewThreadWorker的scheduleActual()方法中做的事情。 4.2.1.NewTreadWorker#schedulerAcutal()123456789101112131415161718192021222324252627282930313233343536373839public NewThreadWorker(ThreadFactory threadFactory) &#123; executor = SchedulerPoolFactory.create(threadFactory);&#125;@NonNullpublic ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) &#123; Runnable decoratedRun = RxJavaPlugins.onSchedule(run); // 1 ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent); if (parent != null) &#123; if (!parent.add(sr)) &#123; return sr; &#125; &#125; Future&lt;?&gt; f; try &#123; // 2 if (delayTime &lt;= 0) &#123; // 3 f = executor.submit((Callable&lt;Object&gt;)sr); &#125; else &#123; // 4 f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit); &#125; sr.setFuture(f); &#125; catch (RejectedExecutionException ex) &#123; if (parent != null) &#123; parent.remove(sr); &#125; RxJavaPlugins.onError(ex); &#125; return sr;&#125; 在NewThreadWorker的scheduleActual()方法的内部，在注释1处首先会新建一个ScheduledRunnable对象，将Runnable对象和parent包装起来了，这里parent是一个DisposableContainer对象，它实际的实现类是CompositeDisposable类，即一个保存所有事件流是否被切断状态的容器，它内部的实现是使用了RxJava自己定义的一个简单的OpenHashSet类进行存储。最后注释2处，判断是否设置了延迟时间，如果未设置，则调用线程池的submit()方法立即进行线程切换，否则，调用schedule()方法进行延时执行线程切换。 问题 为什么多次执行 subscribeOn()，只有第一次有效? 被观察者被订阅时是从最外面的一层（ObservableSubscribeOn）通知到里面的一层（ObservableOnSubscribe)，当连续执行了到多次subscribeOn()的时候，其实就是先执行倒数第一次的subscribeOn()方法，直到最后一次执行的subscribeOn()方法肯定会覆盖前面的线程切换。 observerOn123456789public final Observable&lt;T&gt; observeOn(Scheduler scheduler) &#123; return observeOn(scheduler, false, bufferSize());&#125;public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; .... return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));&#125; 可以看到，observeOn()方法内部最终也是返回了一个ObservableObserveOn对象，我们直接来看看ObservableObserveOn的subscribeActual()方法。 1.ObservableObserveOn#subscribeActual()12345678910111213@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; // 1 if (scheduler instanceof TrampolineScheduler) &#123; // 2 source.subscribe(observer); &#125; else &#123; // 3 Scheduler.Worker w = scheduler.createWorker(); // 4 source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); &#125;&#125; 首先，在注释1处，判断指定的调度器是不是TrampolineScheduler，这是一个不进行线程切换，将当前任务放入队列的调度器。如果是，则会直接调用调用ObservableSubscribeOn的subscribe()方法，如果不是，则会在注释3处创建一个工作者对象。然后在注释4处创建一个新的ObserveOnObserver将SubscribeOnobserver对象包装起来，并传入ObservableSubscribeOn的subscribe()方法进行订阅。接下来看看ObserveOnObserver类的重点方法。 2.ObserveOnObserver123456789101112131415161718192021@Overridepublic void onNext(T t) &#123; ... if (sourceMode != QueueDisposable.ASYNC) &#123; // 1 queue.offer(t); &#125; schedule();&#125;@Overridepublic void onError(Throwable t) &#123; ... schedule();&#125;@Overridepublic void onComplete() &#123; ... schedule();&#125; 去除非主线逻辑的代码，在ObserveOnObserver的onNext()和onError()、onComplete()方法中最后都会调用到schedule()方法。接着看schedule()方法，其中onNext()还会把消息存放到队列中。 3.ObserveOnObserver#scheduler()12345void schedule() &#123; if (getAndIncrement() == 0) &#123; worker.schedule(this); &#125;&#125; 这里使用了worker进行调度ObserveOnObserver这个实现了Runnable的任务,接着看ObserveOnObserver的run()方法。 4.ObserveOnObserver#run()12345678910@Overridepublic void run() &#123; // 1 if (outputFused) &#123; drainFused(); &#125; else &#123; // 2 drainNormal(); &#125;&#125; 5. ObserveOnObserver#drainNormal()12345678910111213141516171819void drainNormal() &#123; int missed = 1; final SimpleQueue&lt;T&gt; q = queue; // 1 final Observer&lt;? super T&gt; a = downstream; ... // 2 v = q.poll(); ... // 3 a.onNext(v); ...&#125; 在注释1处，这里的downstream实际上是从外面传进来的SubscribeOnObserver对象。在注释2处将队列中的消息取出来，接着在注释3处调用了SubscribeOnObserver的onNext方法。最终，会从我们包装类的最外层一直调用到最里面的我们自定义的Observer中的onNext()方法，所以，在observeOn()方法下面的链式代码都会执行到它所指定的线程中 Hot Observable 和 Cold ObservableHot Observable 意思是如果他开始传输数据，你不主动喊停(dispose()/cancel())，那么他就不会停，一直发射数据，即使他已经没有Subscriber了。而Cold Observable则是subscribe时才会发射数据。 Cold Observable我们常见的工厂方法提供的都是Cold Observable,包括just(),fromXX,create(),interval(),defer()。 他们的共同点是当你有多个Subscriber的时候，他们的事件是独立的，举个栗子 123456789101112Observable observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; System.out.println("observable subscribe"); e.onNext("1"); e.onNext("2"); e.onNext("3"); e.onComplete(); &#125;&#125;);observable.subscribe(System.out::println);observable.subscribe(System.out::println); 日志： 12345678observable subscribe123observable subscribe123 通过日志我们发现他们的事件是独立的 Hot Observable那有没有办法让多个订阅者接受到同一事件呢？ 当然有，就是将 Cold Observable 转变为 Hot Observable 123456789101112131415161718Observable observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; Thread.sleep(200); System.out.println("observable subscribe"); e.onNext("1"); e.onNext("2"); e.onNext("3"); e.onComplete(); &#125; &#125;); ConnectableObservable connectableObservable = observable.publish(); connectableObservable.subscribe(System.out::println); connectableObservable.subscribe(System.out::println); Disposable connectDiposable = connectableObservable.connect(); Thread.sleep(1000); connectDiposable.dispose(); 日志： 1234567observable subscribe112233 SubjectSubjects 作为一个Reactive世界中的特殊存在，他特殊在于他自己既是一个Observable又是一个Observer(Subscriber)。你既可以像普通Observable一样让别的Subscriber来订阅，也可以用Subjects来订阅别人。更方便的是他甚至暴露了OnXX()方法给你。你直接调用可以通知所有的Subscriber，举个栗子： 1234PublishSubject&lt;Object&gt; publishSubject = PublishSubject.create();publishSubject.subscribe(System.out::println);publishSubject.subscribe(System.out::println);publishSubject.onNext(new Object()); 通过日志我们发现两个 subscriber 接收到的都是同一对象，这也说明了 Subject 作为被观察者时是 Hot Observable 背压TODO 操作符TODO 参考连接详解RxJava的消息机制和线程切换]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glide 源码分析(1):图片压缩]]></title>
    <url>%2Fblog%2F2019%2F01%2F04%2FGlide-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[关于图片的那点事儿Q: 一张大小为 55KB, 分辨率为 1080 * 480 的 PNG 图片，它加载近内存时所占的大小是多少呢？ 图片内存大小图片占用内存大小 = 分辨率 * 像素点大小 其中数据格式不同像素点大小也不同： ALPHA_8: 1B RGB_565: 2B ARGB_4444: 2B ARGB_8888: 4B RGBA_F16: 8B 现在回过头来看上面的问题，在电脑上显示 55KB 的图片，png 只是这张图片的容器，他们是经过相对应的压缩算法将原图的每个像素点信息转换为另一种数据格式。 在一般情况下，这张图片占用的内容应该是：1080 480 4B = 1.98 M。 每种设备都会有所差异，以 android 为例，我们将同一张图片放在不同 dpi 的 res/drawable 目录下，占用的内存也不一样。 这是因为在 android 中 Bitmap.decodeResource()会根据图片存放的目录做一次宽高的转换，具体公式如下： 转换后高度 = 原图高度 * （设备的 dpi /目录对应的 dpi ） 转换后宽度 = 原图宽度 * （设备的 dip / 目录对应的 dpi） 假设你的手机 dpi 是 320（对应 xhdpi），你将上述的图片放在 xhdpi 目录下： 图片占用内存 = 1080 (320 / 320) 480 (320 / 320) 4B = 1.98 M 同样的手机，将上述图片放到 hdpi (240 dpi) 目录下： 图片占用内存 = 1080 (320 / 240) 480 (320 / 240) 4B = 3.52 M 如果需要查看手机 density 相关配置，可以使用如下命令： adb shell cat system/build.prop|grep density 该命令可得到手机的 dpi，平常我们在布局中的单位都是 dp，那 1 dp 等于多少 px 呢。 根据官方转换公式在 160 dpi 手机下 1 dp 等于 1 px，如果手机 dpi 为 440 dpi，则 1 dp = 2.75 px 如何降低一张图片占用的内存Bitmap 相关属性说明简单了解下BitmapOption的几个相关属性: inBitmap——在解析Bitmap时重用该Bitmap，不过必须等大的Bitmap而且inMutable须为true inMutable——配置Bitmap是否可以更改，比如：在Bitmap上隔几个像素加一条线段 inJustDecodeBounds——为true仅返回Bitmap的宽高等属性 inSampleSize——须&gt;=1,表示Bitmap的压缩比例，如：inSampleSize=4，将返回一个是原始图的1/16大小的 Bitmap inPreferredConfig——Bitmap.Config.ARGB_8888等 inDither——是否抖动，默认为false inPremultiplied——默认为true，一般不改变它的值 inDensity——Bitmap的像素密度 inTargetDensity——Bitmap最终的像素密度 inScreenDensity——当前屏幕的像素密度 inScaled——是否支持缩放，默认为true，当设置了这个，Bitmap将会以inTargetDensity的值进行缩放 inPurgeable——当存储Pixel的内存空间在系统内存不足时是否可以被回收 inInputShareable——inPurgeable为true情况下才生效，是否可以共享一个InputStream inPreferQualityOverSpeed——为true则优先保证Bitmap质量其次是解码速度 outWidth——返回的Bitmap的宽 outHeight——返回的Bitmap的高 inTempStorage——解码时的临时空间，建议16*1024 降低分辨率android 系统提供了相应的 api 可以按比例压缩图片 BitmapFactory.Options.inSampleSize inSampleSzie 值越大，压缩比例越高 改变数据格式 android 系统默认以 ARGB_8888 格式处理图片，那么每个像素点就需要占用 4B 大小，可以将格式改为 RGB_565 Glide 中的图片压缩图片加载的简单过程我们使用 Glide 加载图片的最后一步是 #into(ImageView) 我们直接定位到 RequestBuilder#into(ImageView) 方法： 1234BaseRequestOptions&lt;?&gt; requestOptions = this;... // 根据 ImageView 原生的 scale type 构建 Glide 的 scale typeRequest = buildRequest(target, targetListener, options) // 这里最终调用的是 SingleRequest.obtain() 来创建 requestrequestManager.track(target, request); //从这里开始请求 URL 加载图片 在 tarck() 方法中执行了 targetTracker.track(target)，而这行代码就是用来跟踪生命周期的 如果我们是从网络加载图片，当图片下载成功后会回调 SingleRequest#onResourceReady(Resource&lt;?&gt; resource, DataSource dataSource)方法。 而图片的下载及解码起始于 SingleRequest#onSizeReady,然后调用 Engine#load() 开始下载及解码： 123456... //省略分别从内存，disk 读取图片代码EnginJob&lt;R&gt; engineJob = engineJobFactory.build();DecodeJob&lt;R&gt; decodeJob = decodeJobFacotry.build();josbs.put(key, enginJob);engineJob.addCallback(cb);engineJob.start(decodeJob); //开始解码工作 最后调用 DecodePath#decodeResourceWithList()，关键代码： 123456Resource&lt;ResourceType&gt; result = null;for (int i = 0, size = decoders.size(); i &lt; size; i++) &#123; ResourceDecoder&lt;DataType, ResourceType&gt; decoder = decoders.get(i); result = decoder.decode(data, width, height, options);&#125;return result; 图片解码接下来分析图片的解码过程。 首先我们需要搞清楚 decoders 是怎么来的，原来在初始化 Glide 时会将 Glide 支持的所有 Decoder 注册到 decoderRegistry 中，最终调用 ResourceDecoderRegistry#getDecoders()方法来获取所需要的 decoders: 123456789101112131415161718public synchronized &lt;T, R&gt; List&lt;ResourceDecoder&lt;T, R&gt;&gt; getDecoders(@NonNull Class&lt;T&gt; dataClass, @NonNull Class&lt;R&gt; resourceClass) &#123; List&lt;ResourceDecoder&lt;T, R&gt;&gt; result = new ArrayList&lt;&gt;(); for (String bucket : bucketPriorityList) &#123; List&lt;Entry&lt;?, ?&gt;&gt; entries = decoders.get(bucket); if (entries == null) &#123; continue; &#125; for (Entry&lt;?, ?&gt; entry : entries) &#123; if (entry.handles(dataClass, resourceClass)) &#123; result.add((ResourceDecoder&lt;T, R&gt;) entry.decoder); &#125; &#125; &#125; // TODO: cache result list. return result; &#125; 在Glide中 ResourceDecoder 的实现类有很多，如下图所示 Glide 根据图片的资源类型会调用不同的 Decoder 进行解码，现在我们以最常见的场景，加载网络图片来说明。加载网络图片（PNG格式）调用的是 ByteBufferBitmapDecoder。 不管是加载网络图片还是加载本地资源，都是通过 ByteBufferBitmapDecoder 类进行解码 1234567891011121314151617181920public class ByteBufferBitmapDecoder implements ResourceDecoder&lt;ByteBuffer, Bitmap&gt; &#123; private final Downsampler downsampler; public ByteBufferBitmapDecoder(Downsampler downsampler) &#123; this.downsampler = downsampler; &#125; @Override public boolean handles(@NonNull ByteBuffer source, @NonNull Options options) &#123; return downsampler.handles(source); &#125; @Override public Resource&lt;Bitmap&gt; decode(@NonNull ByteBuffer source, int width, int height, @NonNull Options options) throws IOException &#123; InputStream is = ByteBufferUtil.toStream(source); return downsampler.decode(is, width, height, options); &#125;&#125; 该类很简单，最主要的是调用Downsampler#decode方法，Downsampler 直译向下采样器，接下来就重点看下该类。 Downsampler首先来看 Downsampler对外提供的方法 decode方法 12345678910111213141516171819202122232425 public Resource&lt;Bitmap&gt; decode(InputStream is, int requestedWidth, int requestedHeight, Options options, DecodeCallbacks callbacks) throws IOException &#123; Preconditions.checkArgument(is.markSupported(), "You must provide an InputStream that supports" + " mark()");/* 开始构建 BitmpFactory.Options */ byte[] bytesForOptions = byteArrayPool.get(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, byte[].class); BitmapFactory.Options bitmapFactoryOptions = getDefaultOptions(); bitmapFactoryOptions.inTempStorage = bytesForOptions; DecodeFormat decodeFormat = options.get(DECODE_FORMAT); DownsampleStrategy downsampleStrategy = options.get(DownsampleStrategy.OPTION); boolean fixBitmapToRequestedDimensions = options.get(FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS); boolean isHardwareConfigAllowed = options.get(ALLOW_HARDWARE_CONFIG) != null &amp;&amp; options.get(ALLOW_HARDWARE_CONFIG); try &#123; Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions, downsampleStrategy, decodeFormat, isHardwareConfigAllowed, requestedWidth, requestedHeight, fixBitmapToRequestedDimensions, callbacks); return BitmapResource.obtain(result, bitmapPool); &#125; finally &#123; releaseOptions(bitmapFactoryOptions); byteArrayPool.put(bytesForOptions); &#125; &#125; 该方法首先为 BitmapFactory.Options 设置所需要的参数 inTempStorage Temp storage to use for decoding. Suggest 16K or so. Glide 在这里用的是 64k decodeFormat 解码格式, glide 中的图片主要为两种模式 ARGB_8888, RGB_565 fixBitmapToRequestedDimensions 默认为 false（暂时不太理解这个属性的含义，也无法设置成 true） isHardwareConfigAllowed 硬件位图 默认禁用 123boolean isHardwareConfigSafe = dataSource == DataSource.RESOURCE_DISK_CACHE || decodeHelper.isScaleOnlyOrNoTransform();Boolean isHardwareConfigAllowed = options.get(Downsampler.ALLOW_HARDWARE_CONFIG); 接下来通过 decodeFromWrappedStream 获取 bitmap，该方法主要逻辑如下： 1234567int[] sourceDimensions = getDimensions(is, options, callbacks, bitmapPool); //获取原始图片的宽高 int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth; int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;calculateScaling(); //设置 inSampleSize 缩放(采样)比例calculateConfig();Bitmap downsampled = decodeStream(is, options, callbacks, bitmapPool);callbacks.onDecodeComplete(bitmapPool, downsampled); 我们先来理清这几个size,以 width 为例 sourceWidth: 即你从网络下载的原始图片的宽 requestedWidth: 默认为 ImageView 的宽 targeWidth: 最终生成的 bitmap 的宽 接下来分析 calculateScaling 方法 由于都是计算相关，所以举个栗子，假设图片的sourceWidth 为 1000， targetWidth为 200， sourceHeight为 1200， targetWidth 为 300 123456789101112131415161718192021222324252627final float exactScaleFactor = downsampleStrategy.getScaleFactor(sourceWidth, sourceHeight, targetWidth, targetHeight); //假设向下采样策略为 CenterOutside 实现，则exactScaleFactor 等于 0.25SampleSizeRounding rounding = downsampleStrategy.getSampleSizeRounding(sourceWidth, sourceHeight, targetWidth, targetHeight); //rouding 为 QUALITYint outWidth = round(exactScaleFactor * sourceWidth); //outWidth = 0.25*1000 + 0.5 = 250int outHeight = round(exactScaleFactor * sourceHeight); // outHeight = 0.25*1200 + 0.5 = 300 int widthScaleFactor = sourceWidth / outWidth; //widthScaleFactor = 1000/250 = 4int heightScaleFactor = sourceHeight / outHeight; //heightScalFactor = 1200/300 = 4int scaleFactor = rounding == SampleSizeRounding.MEMORY //scaleFactor = 4 ? Math.max(widthScaleFactor, heightScaleFactor) : Math.min(widthScaleFactor, heightScaleFactor);int powerOfTwoSampleSize = Math.max(1, Integer.highestOneBit(scaleFactor)); //powerOfTowSampleSize = 4，且只可能是 1，2，4，8，16 ...if (rounding == SampleSizeRounding.MEMORY &amp;&amp; powerOfTwoSampleSize &lt; (1.f / exactScaleFactor)) &#123; powerOfTwoSampleSize = powerOfTwoSampleSize &lt;&lt; 1; &#125;&#125;options.inSampleSize = powerOfTwoSampleSize;// 这里暂时还不太理解，看算法这里的 inTragetDesity 和 inDensity 的比值永远为 1if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; options.inTargetDensity = adjustTargetDensityForError(adjustedScaleFactor); options.inDensity = getDensityMultiplier(adjustedScaleFactor);&#125;if (isScaling(options)) &#123; options.inScaled = true;&#125; else &#123; options.inDensity = options.inTargetDensity = 0;&#125; 我们简单看下 CenterOutside类，代码很简单： 12345678910111213 public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) &#123; float widthPercentage = requestedWidth / (float) sourceWidth; float heightPercentage = requestedHeight / (float) sourceHeight; return Math.max(widthPercentage, heightPercentage); &#125; @Override public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) &#123; return SampleSizeRounding.QUALITY; // 返回值有 QUALITY 和 MEMORY,其中 MEMORY 相比较 QUALITY 会占用更少内存 &#125;&#125; 接下来通过调用calculateConfig为 options 设置其他属性 1234567891011121314151617181920212223242526272829303132if (hardwareConfigState.setHardwareConfigIfAllowed( targetWidth, targetHeight, optionsWithScaling, format, isHardwareConfigAllowed, isExifOrientationRequired)) &#123; return;&#125;// Changing configs can cause skewing on 4.1, see issue #128.if (format == DecodeFormat.PREFER_ARGB_8888 || Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN) &#123; optionsWithScaling.inPreferredConfig = Bitmap.Config.ARGB_8888; return;&#125;boolean hasAlpha = false;try &#123; hasAlpha = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool).hasAlpha();&#125; catch (IOException e) &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, "Cannot determine whether the image has alpha or not from header" + ", format " + format, e); &#125;&#125;optionsWithScaling.inPreferredConfig = hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;if (optionsWithScaling.inPreferredConfig == Config.RGB_565) &#123; optionsWithScaling.inDither = true;&#125; 最终调用 ecodeStream 方法，该方法通过对 android api BitmapFactory#decodeStream对图片进行压缩获得了 bitmap 对象 特别注意的是我们在使用 Glide 时加载的网络图片时，默认都是根据 ImageView 的尺寸大小进行了一定比例的，详细的计算过程在上文中也已经提到。但在实际应用中会有希望让用户看到原图场景，这个时候我们可以这样操作 12345ImgurGlide.with(vh.imageView) .load(image.link) .diskCacheStrategy(DiskCacheStrategy.RESOURCE) // 硬盘缓存保存原图 .override(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL) // 重载 requestSize，避免 bitmap 被压缩 .into(vh.imageView); Skia 库在 android 中， BitmapFactory.decodeStream 调用的是 natvie 方法，该函数最终调用的是 skia 库中的encodeStream函数来对图片进行压缩编码。接下来大致介绍一下skia库。 Skia 是一个 c++实现的代码库，在android 中以扩展库的形式存在，目录为external/skia/。总体来说skia是个相对简单的库，在android中提供了基本的画图和简单的编解码功能。另外，skia 同样可以挂接其他第3方编码解码库或者硬件编解码库，例如libpng和libjpeg。在Android中skia就是这么做的，\external\skia\src\images文件夹下面，有几个SkImageDecoder_xxx.cpp文件，他们都是继承自SkImageDecoder.cpp类，并利用第三方库对相应类型文件解码，最后再通过SkTRegistry注册，代码如下所示123static SkTRegistry&lt;SkImageDecoder*, SkStream*&gt; gDReg(sk_libjpeg_dfactory);static SkTRegistry&lt;SkImageDecoder::Format, SkStream*&gt; gFormatReg(get_format_jpeg);static SkTRegistry&lt;SkImageEncoder*, SkImageEncoder::Type&gt; gEReg(sk_libjpeg_efactory); Android编码保存图片就是通过Java层函数——Native层函数——Skia库函数——对应第三方库函数（例如libjpeg），这一层层调用做到的。 最后推荐一个第三方库glide-transformations，可以实现很多图片效果，比如圆角，高斯模糊，黑白。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Glide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴开源路由框架 - ARouter 分析]]></title>
    <url>%2Fblog%2F2019%2F01%2F04%2F%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E8%B7%AF%E7%94%B1%E6%A1%86%E6%9E%B6-ARouter-%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Arouter 一个用于帮助 Android App 进行组件化改造的框架 —— 支持模块间的路由、通信、解耦 技术准备 SPI APT 源码分析我们直接看官方 demo，核心模块包括api,compiler,annotation, 首先先简单讲一下各模块的作用： Annoation: 定义注解和 Route 相关的基本信息 Compiler: 主要是用来在编译期间处理注解Router/Interceptor/Autowire三个注解，在编译期间自动注册注解标注的类，成员变量等。 Api: 用户调用的核心 api annoationAutowired 用于注解 field, 可实现路由件传递参数的自动注入，无需使用者在代码中去获取传递的参数，注意，注解对象的修饰符不能是 private。 Interceptor 用于注解拦截器，拦截器的概念请参考官方文档 Route 路由注解，可以是 Activity，也可以是 Service RouteMeta 路由相关的数据，包括路由类型，路径，组，权重，参数等信息 compilerRouteProcessor路由注解器 关键方法 #parseRoutes#,我们先看这个方法最后生成的文件到底是啥，弄清楚了才能更容易的理清代码。 123456789public class ARouter$$Root$$app implements IRouteRoot &#123; public ARouter$$Root$$app() &#123; &#125; public void loadInto(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes) &#123; routes.put("service", service.class); routes.put("test", test.class); &#125;&#125; 注意map 存入的key 分别是 service 和 test，valude 则对应为 ARouterGroupservice.class 和 ARouterGrouptest.class。一个组件有且只有一个 Root 类，不同的组件以后缀作为区分。 12345678public class ARouter$$Group$$test implements IRouteGroup &#123; public ARouter$$Group$$test() &#123; &#125; public void loadInto(Map&lt;String, RouteMeta&gt; atlas) &#123; atlas.put("/test/*", RouteMeta) &#125;&#125; 12345678public class ARouter$$Group$$service implements IRouteGroup &#123; public ARouter$$Group$$service() &#123; &#125; public void loadInto(Map&lt;String, RouteMeta&gt; atlas) &#123; atlas.put("/service/*", RouteMeta) &#125;&#125; 注意 ArouterGrouptest 中 map 的 key 必然是以 “/test” 为前缀，刚好与其后缀相同 12345678public class ARouter$$Providers$$app implements IProviderGroup &#123; public ARouter$$Providers$$app() &#123; &#125; public void loadInto(Map&lt;String, RouteMeta&gt; providers) &#123; providers.put(className, RouteMeta) &#125;&#125; 12345678public class ARouter$$Interceptors$$app implements IInterceptorGroup &#123; public ARouter$$Interceptors$$app() &#123; &#125; public void loadInto(Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptors) &#123; interceptors.put(privority, Class); &#125;&#125; 小结一下： 在一个module中，自动生成的 IRouteRoot 类有且只有一个，后缀为 module 名 在一个module中，自动生成的 IRouteGroup 类可以有多个，且都会在 IRouteRoot 类中注册 IProviderGroup 只有一个，后缀为 module 名 准确来说后缀并不是 module 名，实际上你可以在 gradle 中指定，后续在讲解 parseRoutes 方法时会讲到具体原因 接下来将讲解 RouteProcessor#parseRoutes 方法: 拿到 Route，根据 RouteType 构建 RouteMeta，并通过 #categoryies 方法构建映射关系存储到 groupMap(groupMap 的 key 为 routeName ，value 则是 RouteMeta 集合) 遍历 groupMap 创建 ARouter$$Group$$groupName 类, 同时将 groupName 与生成的 File 的全类名的映射关系存储到 rootName 创建 ARouter$$Providers$$moduleName 类 创建 ARouter$$Rout$$moudleName 其中 groupName 就是你在注解中设置的 group，但我们平时在使用 ARouter 的时候很少回去设置 group, 如果你没有指定 group，Arouter 会默认使用 path 的主路径，比如你指定了 path = “/test/main”, 那 groupName 就是 test; moudleName 则由你在 gradle 中指定。 AutoWiredProccesor首先看一下生成的文件：1234567891011121314public class Test1Activity$$ARouter$$Autowired implements ISyringe &#123; private SerializationService serializationService; public Test1Activity$$ARouter$$Autowired() &#123; &#125; public void inject(Object target) &#123; this.serializationService = (SerializationService)ARouter.getInstance().navigation(SerializationService.class); Test1Activity substitute = (Test1Activity)target; substitute.name = substitute.getIntent().getStringExtra("name"); ... substitute.helloService = (HelloService)ARouter.getInstance().navigation(HelloService.class); &#125;&#125; 生成的 class 继承之 ISyring只有一个方法 inject(Object),该方法的实现主要做了两件事： AutoWired 注解的 filed 如果是 service (Arouter 中继承自 IProvider), 则初始化对象： 1substitute.helloService = (HelloService)ARouter.getInstance().navigation(HelloService.class); AutoWried 注解的 filed 非 service,则从 bundle 中获取相应的 value 赋值给该 field: 12substitute.helloService = (HelloService)ARouter.getInstance().navigation(HelloService.class); // activitysubstitute.name = substitute.getArguments().getString("name"); // fragment 最后生成类名$$Arouter$$AutoWired.class 文件 InterceptorProccessor拦截注解生成器 12345678public class ARouter$$Interceptors$$app implements IInterceptorGroup &#123; public ARouter$$Interceptors$$app() &#123; &#125; public void loadInto(Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptors) &#123; interceptors.put(7, Test1Interceptor.class); &#125;&#125; apiARouter &amp; _ARouterlauncher 下只有两个类 ARouter, _ARouter, ARouter 采用单例模式，对外提供 ARouter 相关 API,我们在调用ARouter.getInstance().build()时 真正调用的是_ARouter的相关方法，这里采用了代理模式，现在我们就开始以 ARouter 向外提供的方法来逐步分析： 首先看init():在 Arouter 库中，有一个 Warehose类，它存储了路由相关的信息，我们在使用 ARouter 之前必须要先调用 init 方法，而 init方法就是需要将信息存储到 Warehose 中以下为时序图： 通过调用#loadInto(Warehose)方法，成功地将信息存储到 Warehose。 现在Warehose 的 groupsIndex, providersIndex, interceptorsIndex 已经被我们存入了路由信息 最后再调用_ARouter#afterInit()实例化 interceptorService 接下来是 navigation()方法: 我们需要先了解Postcard 类,Postcard 继承 RouteMeta，扩展了一些属性，例如：flag(activity 的 flag)，uri，provider，anim(动画)。我们平时在是用 Arouter 时 build 方法返回的就是 Postcasrd, postcard#navigation 方法，最终调用的是就是 _Arouter#navaigation 123456789101112LogisticsCenter.completion(postcard);if(!postcard.isGreenChannel()) &#123; // 拦截器相关，暂时跳过 interceptorSevice.doInterceptions(post, new InterceptorCallback() &#123; @Override public void onContinue(Postcard postcard) &#123; _navigation(context, postcard, requestCode, callback); &#125; &#125;)&#125; else &#123; return _navigation(context, postcard, requestCode, callback);&#125; 首先我们来看LogisticsCenter#completion(Postcard)方法 123456789101112131415161718192021222324252627...RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());if (null == routeMeta) &#123; Class&lt;? extends IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup()); // Load route meta. IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance(); // ARouter$$Group%%test 对象实例化 iGroupInstance.loadInto(Warehouse.routes); Warehouse.groupsIndex.remove(postcard.getGroup()); completion(postcard); // Reload 进入 else 分支&#125; else &#123; ... // postcadrd 设置属性如：destination,type,priority等 switch(routeMeta.getType) &#123; case PROVIDER: Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination(); IProvider instance = Warehouse.providers.get(providerMeta); if(instance == null) &#123; IProvider povider = providerMeta.getConstructor().newInstance(); provider.init(mContext); // init 方法只在创建 provider 对象后调用一次, Warehose.providers.put(providerMeta, provider); // 存入 map，除非调用 ARouter#destory, 该 provider 对象会一直存在 map 中 postcard.setProvider(instance); postcard.greenChannel(); &#125; break; case FRAGMENT: ... break; &#125;&#125; 到这里面 Warehose 中的 routes 和providers也被我们放入了相应信息 _navigation()方法： 123456789101112131415switch(postcard.getType()) &#123; case ACTIVITY: ... // build intent startActivity(requestCode, currentCotext, intent, postcard, callback); break; case POSTCARD: return postcard.getProvider(); case Fragment: Fragment fragment = fragmentMeta.getConstructor().newInstance(); fragment.setArguments(postcard.getExtras()); return fragment; default: return null;&#125;return null; 接下来分析 ARroute#inject(Object)方法： 12AutowiredService autowiredService = ((AutowiredService) ARouter.getInstance().build("/arouter/service/autowired").navigation());autowiredService.autowire(objec); 代码很简单，关键是 AutowiredService 的实现 12345678910111213141516@Overridepublic void autowire(Object instance) &#123; String className = instance.getClass().getName(); try &#123; if (!blackList.contains(className)) &#123; ISyringe autowiredHelper = classCache.get(className); if (null == autowiredHelper) &#123; // No cache. autowiredHelper = (ISyringe) Class.forName(instance.getClass().getName() + SUFFIX_AUTOWIRED).getConstructor().newInstance(); // $$ARouter$$Autowired = $$ARouter$$Autowired &#125; autowiredHelper.inject(instance); // Text1Activity$$ARouter$$Autowired.inject(this) 取出 bundle 中传递的参数 classCache.put(className, autowiredHelper); &#125; &#125; catch (Exception ex) &#123; blackList.add(className); // This instance need not autowired. &#125;&#125; 到这里，所有的注解生成的 class 的作用及其实现方法的调用时机都已经介绍到了，相信读者应该对 ARouter 有了新的了解了吧。接下来讲一下我们平时比较少用到的 interceptor ARouter官方为我们提供了一个拦截器的使用场景: 12&gt; 比较经典的应用就是在跳转过程中处理登陆事件，这样就不需要在目标页重复做登陆检查&gt; 还记得在讲解 ARroute#navigation时我们跳过了拦截器相关的内容吗 123456789if(!postcard.isGreenChannel()) &#123; // 拦截器相关，暂时跳过 interceptorSevice.doInterceptions(post, new InterceptorCallback() &#123; @Override public void onContinue(Postcard postcard) &#123; _navigation(context, postcard, requestCode, callback); &#125; &#125;)&#125; 只要是拦截器，一般都会使用责任链设计模式，在 ARouter中也不例外,我们先看 interceptorService的创建过程，它的 type 是 Provider，在创建后会首先调用 init方法 1234567891011121314@Overridepublic void init(final Context context) &#123; LogisticsCenter.executor.execute(new Runnable() &#123; @Override public void run() &#123; for(entry : Warehose.interceptorsIndex) &#123; Class&lt;? extends IInterceptor&gt; interceptorClass = entry.getValue(); IInterceptor iInterceptor = interceptorClass.getConstructor().newInstance(); iInterceptor.init(context); Warehose.interceptors.add(iInterceptor); &#125; &#125; &#125;&#125; interceptorService#doInterceptions 调用 _excute 方法 12345678910111213141516171819private static void _excute(final int index, final CancelableCountDownLatch counter, final Postcard postcard) &#123; if (index &lt; Warehouse.interceptors.size()) &#123; IInterceptor iInterceptor = Warehouse.interceptors.get(index); iInterceptor.process(postcard, new InterceptorCallback() &#123; @Override public void onContinue(Postcard postcard) &#123; // Last interceptor excute over with no exception. counter.countDown(); _excute(index + 1, counter, postcard); // When counter is down, it will be execute continue ,but index bigger than interceptors size, then U know. &#125; @Override public void onInterrupt(Throwable exception) &#123; // Last interceptor excute over with fatal exception. postcard.setTag(null == exception ? new HandlerException("No message.") : exception.getMessage()); // save the exception message for backup. counter.cancel(); &#125; &#125;); &#125; 常见错误分析 service 内存泄漏, 考虑以下代码： 12345678910111213public class HelloServiceImpl implements HelloService &#123; private Context context; @Override public void init(Context context) &#123; this.context = context &#125; @Override public void say() &#123; Toast.makeText(context, R.string.hello, Toast.LENGTH_LONG).show(); &#125;&#125; 之前我们分析源码的时候就已经讲过了，service 的实现类在初始化后会被放入Warehose.providers，后续通过调用ARouter.inject都是从Warehose.providers中取出。在上面的代码中如果 context 是一个 activity 对象，将该 activity 赋值给了成员变量 context，则该 activity 对象不会被回收，造成了内存泄漏 混淆导致 service 为 null 123456789101112public class HelloHolder &#123; @Autowired(name = "/service/hello") HelloService helloService; public HelloHolder() &#123; ARouter.getInstance().inject(this); &#125; public void sayHello() &#123; helloSerice.say; &#125;&#125; 该代码本身并没有问题，问题出在在 android 开发中我们需要混淆代码，大家还记得之前讲的 AutowiredService 的实现吧，关键代码在这里， 123if (null == autowiredHelper) &#123; // No cache. autowiredHelper = (ISyringe) Class.forName(instance.getClass().getName() + SUFFIX_AUTOWIRED).getConstructor().newInstance(); // $$ARouter$$Autowired = $$ARouter$$Autowired&#125; 本来 ARouter 构建的类名应该是 HelloHolder$$ARouter$$Autowired, 然后实例化该对象，调用该对象的 #inject方法，可是你现在将 HelloHolder混淆成了H,导致创建对象失败，这就是你为什么在代码中调用了 ARouter.getInstance().inject(this)，但是 service 还是为 null 的原因 在 android 开发中，Activity，Fragment 我们在混淆规则中是配置了 keep 等规则的，所以不会有问题。但是像上文中 HelloHolder 这种情况常常被我们所忽略，在开发中一定要注意，建议采用注解方式来保持类名不被混淆。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Alibaba</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 开发之 APT 技术]]></title>
    <url>%2Fblog%2F2019%2F01%2F04%2FAndroid-%E5%BC%80%E5%8F%91%E4%B9%8B-APT-%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[APT，就是Annotation Processing Tool 的简称，就是可以在代码编译期间对注解进行处理，并且生成Java文件，减少手动的代码输入。一些大名鼎鼎的框架如 Retrofit, Arouter 都运用了 APT 技术。 在本片文章中我们将利用 APT 技术实现类似 ARouter 的路由功能. 不多说，先附上本文中的代码地址：APTdemo https://github.com/square/javapoet 实现效果常用的 Activity 跳转方式： 1startActivity(new Intent(MainActivity.this, TwoActivity.class)); 我们希望通过以下方式达到 Activity 跳转的目的： 1SRouter.getInstance().navigate(MainActivity.this, "router_two"); 注解创建annotationlibrary, 首先我们在 library 中定义注解，通过它我们可以找到哪些 Activity 需要添加到路由中 12345@Retention(RetentionPolicy.CLASS)@Target(ElementType.TYPE)public @interface Router &#123; String name();&#125; 注解处理器 - compile创建compilelibrary,依赖 annotation模块， 注意创建的时候选择 java-libray， 创建RouterProcessor类继承自 AbstractProcessor。我们需要实现 4 个方法，前3个方法简单的写法很固定，简单讲一下他们的作用吧； init()方法可以初始化拿到一些使用的工具，比如文件相关的辅助类 Filer;元素相关的辅助类Elements;日志相关的辅助类Messager; getSupportedSourceVersion()方法返回 Java 版本; getSupportedAnnotationTypes()方法返回要处理的注解； 其中最核心的是 process()方法，通过javapoet 再结合注解我们就可以成相应的类。 最终我们希望生成的类是这样的： 1234567891011public final class Router$$GroupApp implements IRouterGroup &#123; private Map&lt;String, String&gt; routeMap = new HashMap(); public Router$$GroupApp() &#123; this.routeMap.put("router_two", "com.slyser.aptdemo.TwoActivity"); &#125; public String getActivityName(String routeName) &#123; return null != this.routeMap &amp;&amp; !this.routeMap.isEmpty() ? (String)this.routeMap.get(routeName) : ""; &#125;&#125; 实现代码并不复杂，就是写起来很繁琐，还好 javapoet 为我们省了不少事。 注册注解处理器编译的时候 JVM 怎么找到我们自定义的注解处理器？这个时候就要用到 SPI 机制。简单的用法就是在 compile 模块下新建 resources/META-INF/services 文件，创建这个文件很容易出错，大家可以使用 google 出品的 auto-service，通过注解就可以很方便的问我们创建相应的文件 添加auto-service的 gradle 依赖:implementation ‘com.google.auto.service:auto-service:1.0-rc3’ 核心库 - api创建 api library, 该库很简单，就只有 SRouter 一个类，核心就是反射创建注解处理器生成的对象，拿到 Activity 的 Class，完成 activity 的跳转. 使用在 Activity 上添加注解12@Router(name = "router_two")public class TwoActivity extends AppCompatActivity 跳转1SRouter.getInstance().navigate(this, "router_two"); 这样一个简单的路由跳转就完成了 总结APT技术其实就是自定义注解和注解处理器，在编译期间生成Java文件，类似于IOC控制反转，可以方便的进行解耦，在多模块开发时可以基于APT技术构造一套路由框架，去除startActivity等造成的类依赖。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>APT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPI 介绍与使用]]></title>
    <url>%2Fblog%2F2019%2F01%2F04%2FSPI-%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介SPI全称是Service Provider Interface，服务提供方接口，服务通常是指一个接口或者一个抽象类，服务提供方是对这个接口或者抽象类的具体实现，由第三方来实现接口提供具体的服务。SPI提供了一种动态的对应用程序进行扩展的机制，通常用作框架服务的拓展或者可替换的服务组件。 SPI机制 在resources/META-INF/services/目录中创建以服务全限定名命名的文件，该文件内容为服务的具体实现类的全限定名，文件中可以写多个服务的具体实现类 使用ServiceLoader类动态加载服务的具体实现类 服务具体的实现类必须有一个不带参数的构造方法 使用定义接口或抽象类123public interface MessageService &#123; String getMessage();&#125; 实现接口123456public class AMessageService implements MessageService &#123; @Override public String getMessage() &#123; return "Hello from module A"; &#125;&#125; 123456public class BMessageService implements MessageService &#123; @Override public String getMessage() &#123; return "Welcome from b"; &#125;&#125; 创建 SPI 描述文件如下图所示，注意目录结构: 可以使用 google 推出的 auto-service，它可以方便的帮我们生成对应的描述文件，用法很简单 使用 auto-service: 依赖 implementation &#39;com.google.auto.service:auto-service:1.0-rc3&#39; 在 Service 实现类使用注解 @AutoService 1234567@AutoService(MessageService.class)public class BMessageService implements MessageService &#123; @Override public String getMessage() &#123; return "Welcome from b"; &#125;&#125; 调用具体服务使用ServiceLoader去加载具体服务类，然后遍历具体的实现类，ServiceLoader其实就是去META-INFO/services目录下读取文件内容，然后实例化。 1234ServiceLoader&lt;MessageService&gt; serviceServiceLoader = ServiceLoader.load(MessageService.class);for (MessageService messageService : serviceServiceLoader) &#123; Log.d("auto service", "msg:" + messageService.getMessage());&#125; 优点只提供服务接口，具体服务由其他组件实现，接口和具体实现分离，同时能够通过系统的ServiceLoader拿到这些实现类的集合，统一处理。 缺点 Java中SPI是随jar发布的，每个不同的jar都可以包含一系列的SPI配置，而Android平台上，应用在构建的时候最终会将所有的jar合并，这样很容易造成相同的SPI冲突，常见的问题是DuplicatedZipEntryException异常 读取SPI配置信息是在运行时从jar包中读取，由于apk是签过名的，在从jar中读取的时候，签名校验的耗时问题会造成性能损失 在运行时通过反射加载类实例，会造成性能损失 总结在 android 项目中几乎已经见不到 SPI 的使用了，如果想达到组件间通讯同时又减少性能损失，可以使用 APT 在编译时生产成对应的 Service，再通过依赖注入获取到 Service 的实例。不过在 APT 中我们又会使用SPI 技术，所以笔者觉得有必要先讲一下 SPI. 参考 demo]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Architecture Components]]></title>
    <url>%2Fblog%2F2019%2F01%2F04%2FAndroid-Architecture-Components%2F</url>
    <content type="text"><![CDATA[Android Architecture Components 提供从管理 UI 组件的生命周期到处理数据持久性的一系列库，来帮助您设计健壮，易测试和维护的 App。 本文将简单介绍 Lifcycle, LiveData, ViewModel 的使用并对一些重要的源码进行分析 集成请参阅官方文档 在项目中添加组件 Lifecycle介绍 假设我们这里有一个具有生命周期的组件 A (例如 Activity 或 Fragment)，而另一个组件 B 需要响应 A 组件的生命周期，传统的方式是在组件 A 的生命周期依赖组件 B，但是这种方式导致代码健壮性较低，同时易导致一系列的错误。使用 Lifecycle 组件，您可以将组件 B 的代码从组件 A 的生命周期方法中移到组件本身 Lifecycle 的使用以 MyLocationManager 为例,添加相关生命周期的注解。 1234567891011121314151617class MyLocationManager : LifecycleObserver &#123; @OnLifecycleEvent(ON_CREATE) fun onCreate() &#123; glog("location onCreate") &#125; @OnLifecycleEvent(ON_START) fun onStart() &#123; glog("locatoin onstart") &#125; @OnLifecycleEvent(ON_DESTROY) fun onDestroy() &#123; glog("locatoin ondestory") &#125;&#125; 然后创建 MyLocationManager 实例，然后就可以监听到 Activity 或 Fragment 的生命周期变化。 123456override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val locationManager = LocationManager() lifecycle.addObserver(locationManager)&#125; addObserver 这个方法有一个小细节需要注意一下： 123456789101112/** * Adds a LifecycleObserver that will be notified when the LifecycleOwner changes * state. * &lt;p&gt; * The given observer will be brought to the current state of the LifecycleOwner. * For example, if the LifecycleOwner is in &#123;@link State#STARTED&#125; state, the given observer * will receive &#123;@link Event#ON_CREATE&#125;, &#123;@link Event#ON_START&#125; events. * * @param observer The observer to notify. */@MainThreadpublic abstract void addObserver(@NonNull LifecycleObserver observer); 如果 LifecycleOwner 当前的状态是 STATED，当我们调用 addObserver 方法时，会接收到 ON_CREATE 和 ON_START events. 以 MyLocationManager 为例说明，当我们在 Activity 的 onResume 方法中 addObserver 时，MyLocationManager 仍然会执行 onCreate 和 onStart 方法. UML 类图 Event and StateEven 和 State 是 Lifecycle 中很重要的概念，结合自己的代码与 google 官方的配图相信应该很容易理解. 关键源码我们在查看源码时发现 Lifecycle 只在 Activity 的 onSaveInstanceState 中 调用了 mLifecycleRegistry.markState(Lifecycle.State.CREATED) 方法，在其他生命周期中并没有 Lifecycle 的相关代码，那 support 库中是怎么做到 disptch event 的呢？ 原来在 onCreate 中有一行关键代码，它创建了一个不可见的 fragment 去分发 event 1ReportFragment.injectIfNeededIn(this); 12345678910111213141516 @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); dispatchCreate(mProcessListener); dispatch(Lifecycle.Event.ON_CREATE); &#125;... @Override public void onDestroy() &#123; super.onDestroy(); dispatch(Lifecycle.Event.ON_DESTROY); // just want to be sure that we won't leak reference to an activity mProcessListener = null; &#125; 思考一下 google 为什么要采用这样的方式，而不是直接在 Activity 的生命周期去直接分发 event 呢？以刚才的 MyLocationManager 为例, 如果打印 Activity 和 MyLocationManager 的完整生命周期日志，会得到以下结果:12345678910 05-25 06:59:17.382 32431-32431/com.slyser.arc D/arc: activity onCreate location onCreate05-25 06:59:17.385 32431-32431/com.slyser.arc D/arc: activity onStart location onStart05-25 06:59:17.386 32431-32431/com.slyser.arc D/arc: activity onResume location onResume05-25 06:59:36.675 32431-32431/com.slyser.arc D/arc: location onStop activity onStop location onDestroy05-25 06:59:36.676 32431-32431/com.slyser.arc D/arc: activity onDestroy 可以看到进入 Activity 时的执行顺序: Activity -&gt; MyLocationManager.退出 Activity 时的执行顺序刚好相反: MyLocationManager -&gt; Activity.而直接在 Activity 的生命周期中直接分发 event 是达不到这种效果的。 LiveData介绍 LiveData 是一个可观察的数据持有者。与常规可观察性不同，LiveData 具有生命周期感知能力，这意味着它尊从其他应用程序组件（例如 Activity, Fragment, Service）的生命周期。 这种设计确保 LiveData 只更新处于活动生命周期状态的应用程序组件观察者。如果观察者的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会将观察者视为活动状态。LiveData 仅将更新通知给活跃的观察者，未注册和非活动的观察者不会收到有关更新的通知。 LiveData 的使用首先我们先创建一个 LiveData,然后一个简单的方法调用，我们在监听数据变化时传入了两个参数，前者 owner 用于将 livedata 与生命周期绑定，后者监听数据的变化，这样你就能使用 LiveData 了 1public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer) 1234567891011121314class MainActivity : AppCompatActivity() &#123; val liveData = MutableLiveData&lt;Person&gt;() override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) liveData.observe(&#123;this@MainActivity.lifecycle&#125;, &#123; it?.let &#123; glog(it.name) &#125; &#125;) findViewById&lt;Button&gt;(R.id.btn).setOnClickListener &#123; liveData.value = Person("zhangsan") &#125; &#125; data class Person(var name:String)&#125; 关键源码之前介绍概念中有一段这样的话很重要: 如果观察者的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会将观察者视为活动状态。LiveData 仅将更新通知给活跃的观察者。 怎么理解这段话呢，执行如下代码，看下日志的打印内容： 12345678910111213141516171819class MainActivity : AppCompatActivity() &#123; private val person : Person = Person("live data onCreate") val liveData = MutableLiveData&lt;Person&gt;() override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) liveData.observe(&#123;this@MainActivity.lifecycle&#125;, &#123; it?.let &#123; glog(it.name) &#125; &#125;) liveData.value = person &#125; override fun onStart() &#123; super.onStart() person.name = "live data onStart" &#125; data class Person(var name:String)&#125; 日志打印出的 name 是 live data onStart, 在 onCreate 方法中明明改变了 LiveData 的值，为什么打印的 name 不是 live data onCreate 呢？ 原来我们在虽然在 onCreate 中调用了 setValue 方法，但是此时 LiveData 的 active 状态为 false 并不会通知数据变化. 1234567@MainThread protected void setValue(T value) &#123; assertMainThread("setValue"); mVersion++; // 管理数据变化的版本 mData = value; dispatchingValue(null); &#125; 12345678910111213141516171819private void dispatchingValue(@Nullable ObserverWrapper initiator) &#123; ... do &#123; mDispatchInvalidated = false; if (initiator != null) &#123; considerNotify(initiator); initiator = null; &#125; else &#123; for (Iterator&lt;Map.Entry&lt;Observer&lt;T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123; considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) &#123; break; &#125; &#125; &#125; &#125; while (mDispatchInvalidated); mDispatchingValue = false;&#125; 1234567891011private void considerNotify(ObserverWrapper observer) &#123; if (!observer.mActive) &#123; // 在 onCreate 中此时的活动状态为 false return; &#125;... if (observer.mLastVersion &gt;= mVersion) &#123; return; //active 状态变化了，但是数据版本没有增加，不会调用 onChange &#125; observer.mLastVersion = mVersion; observer.mObserver.onChanged((T) mData);&#125; 然后当 Activity 的生命执行到 onStart 后，此时 active 状态变化为 true，最终调用 observer.mObserver.onChanged((T) mData)，通知 LiveData 数据变化，但此时 person 的 name 已经变为 live data onStart 了. 123456789void activeStateChanged(boolean newActive) &#123; if (newActive == mActive) &#123; return; &#125; ... if (mActive) &#123; dispatchingValue(this); &#125; &#125; TransformationsTransformations 可以让 LiveData 在不同数据类型间进行变换，相关代码如下: 1234567891011 LiveData userLiveData = ...; LiveData userName = Transformations.map(userLiveData, user -&gt; &#123; return user.firstName + " " + user.lastName &#125;);MutableLiveData userIdLiveData = ...; LiveData userLiveData = Transformations.switchMap(userIdLiveData, id -&gt; repository.getUserById(id)); void setUserId(String userId) &#123; this.userIdLiveData.setValue(userId); &#125; ViewModel介绍 ViewModel 目的在于以生命周期的形式存储和管理与 UI 相关的数据。 ViewModel 允许数据在配置变化（例如屏幕旋转）后仍然存活。 生命周期 ViewModel 的使用ViewModel 的使用很简单，创建一个类继承 ViewModel 123class UserViewModel : ViewModel() &#123; &#125; 如果你想在 ViewModel 中使用 Context，可以继承 AndroidViewModel,然后通过一行代码即可得到 ViewModel 对象 1val viewModel = ViewModelProviders.of(this).get(UserViewModel::class.java) 关键源码首先看ViewModelProviders.of的相关代码 12345678910@NonNull @MainThread public static ViewModelProvider of(@NonNull FragmentActivity activity, @Nullable Factory factory) &#123; Application application = checkApplication(activity); if (factory == null) &#123; factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application); &#125; return new ViewModelProvider(ViewModelStores.of(activity), factory); &#125; ViewModelProviders.of 创建了一个 ViewModelProvider 对象，ViewModelProvider 构造方法传递两个参数 ViewModelStore 和 Factory ，Factory 很简单，就是让你自己决定如何创建 ViewModel，如果 factory 为 null 则使用 android 提供的默认实现，ViewModelStore 简单来说就是个存放 ViewModel 对象的 map，key 默认为类名. 12345678@NonNull @MainThread public static ViewModelStore of(@NonNull FragmentActivity activity) &#123; if (activity instanceof ViewModelStoreOwner) &#123; return ((ViewModelStoreOwner) activity).getViewModelStore(); &#125; return holderFragmentFor(activity).getViewModelStore(); // 兼容27.1.0以下版本的 support 库 &#125; 其中ViewModelStoreOwner是一个接口，只有一个方法，在 27.1.0 的 FragmentActivity 已经实现了该接口 1ViewModelStore getViewModelStore(); 27.1.0 以下的版本 google 则通过创建一个不可见的实现 ViewModelStoreOwner接口的 fragment 去做兼容，以下是相关关键代码 12345678910111213141516171819HolderFragment holderFragmentFor(FragmentActivity activity) &#123; FragmentManager fm = activity.getSupportFragmentManager(); HolderFragment holder = findHolderFragment(fm); if (holder != null) &#123; return holder; &#125; holder = mNotCommittedActivityHolders.get(activity); if (holder != null) &#123; return holder; &#125; if (!mActivityCallbacksIsAdded) &#123; mActivityCallbacksIsAdded = true; activity.getApplication().registerActivityLifecycleCallbacks(mActivityCallbacks); //注册生命周期，activity 销毁时将 HolderFragment 从 mNotCommittedActivityHolders 移除 &#125; holder = createHolderFragment(fm); mNotCommittedActivityHolders.put(activity, holder); return holder;&#125; 搞清楚了ViewModelStore再回过头来看ViewModelProvider的 get 方法 1234567891011121314151617181920@NonNull @MainThread public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; ViewModel viewModel = mViewModelStore.get(key); // mViewModelStore为构造方法传递 if (modelClass.isInstance(viewModel)) &#123; //store 中存储了 ViewModel 则直接返回 //noinspection unchecked return (T) viewModel; &#125; else &#123; //noinspection StatementWithEmptyBody if (viewModel != null) &#123; // TODO: log a warning. &#125; &#125; viewModel = mFactory.create(modelClass); //store 中没有 ViewModel 则创建一个 ViewModel，并在 ViewModelStore 中的 map 中存放 mViewModelStore.put(key, viewModel); //noinspection unchecked return (T) viewModel; &#125; 总结一下: 如果使用的 support 库为 27.1.0 以上则 Activity 和 Fragment 都实现了 ViewModelStoreOwner 接口，提供ViewModelStore实例 如果使用的 support 库为 27.1.0 以下，则会创建一个 HolderFragment，同样实现了 ViewModelStoreOwner 接口，提供ViewModelStore实例 ViewModelStore本质是默认 key 为类名 value 为 ViewModel 的 map 在 fragment 间共享数据我们在不同的 fragment 中调用 ViewModelProviders.of() 时，如果参入的参数为 activity，则获取的 ViewModel 对象为同一实例，代码如下： 1val viewModel = ViewModelProviders.of(getActivity()).get(UserViewModel::class.java) 这样我们就可以在两个或更多 fragment 间彼此间进行通信。 最佳实践 尽可能保持您的 UI 控制器（activity 和 fragment）精简。他们不应该试图获取他们自己的数据;相反，使用 ViewModel 来做到这一点，并通过监听 LiveData 对象来更新视图。 尝试编写数据驱动的用户界面，其中您的 UI 控制器的职责是在数据更改时更新视图，或将用户操作通知给ViewModel。 把你的数据逻辑放在 ViewModel 类中。 ViewModel 应作为您的 UI 控制器和其他应用程序之间的连接器。 但要小心，ViewModel 不负责提取数据（例如，来自网络）。 相反，ViewModel 应调用相应的组件来获取数据，然后将结果提供给UI控制器 使用 Data Binding 在视图和 UI 控制器之间保持干净的界面。 这可以使您的视图更具说明性，并最大限度地减少需要在 activity 和 fragment 中编写的更新代码。 如果你喜欢用 java 编程语言来做到这一点，可以使用像 Butter Knife 这样的库来避免样板代码并且能够更好的抽象。 如果您的 UI 很复杂，请考虑创建一个 presenter 来处理 UI 修改。这可能是一项艰巨的任务，但它可以使您的 U I组件更易于测试。 避免在 ViewModel 中引用 View 或 Activity 上下文。如果 ViewModel 存活的时间比 Activity（在配置更改的情况下），将会造成 activity 的内存泄漏]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[All categories]]></title>
    <url>%2Fblog%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[All tags]]></title>
    <url>%2Fblog%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
